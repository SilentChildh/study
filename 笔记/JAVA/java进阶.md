# 静态变量

静态变量也称类变量



## 语法

**访问修饰符 static 数据类型 变量名;**

也可以 static 访问修饰符 数据类型 变量名;

## 特点

- 静态变量是同一个类所有对象共享的
- 在类信息加载时就已经生成，随着类的消亡而销毁

jdk8以后静态变量存放于堆区中类对象中，

通过反射机制加载类对象（当类信息在方法区中加载的时候，它会在堆区中生成一个对应的class对象。）

## 用法

**类名.静态变量名;**

也可以对象名.静态变量名;



## 用途

1. 当需要让某个类所有对象共享一个变量时，就可以考虑使用静态变量



# 静态方法

静态方法也称类方法

## 语法、用法

与静态变量相似

## 特点

1. 所有对象共享
2. 在类信息加载时就以生成，位于方法区中，随对象消亡而销毁
3. 不可使用与对象有关的关键字，如this、super
4. 静态方法只能访问静态成员

## 用途

1. 当方法中不涉及任何和对象相关的成员，则可以将方法设计成静态方法，提高开发效率（一般工具类都是static方法）





# main方法解析

1. 被jvm所调用

2. 必须public

3. 必须static

4. 对于String[] args形参是：在执行java命令时，在后面多加的几个实参。

    （如在dos内执行命令：java Hello 实参1 实参2 实参3）

    （在idea中，可以在运行时，edit run/debug configuration 中的 pogram arguments， 即传入动态参数）



# 代码块

代码块也称初始化块

在加载类或者创建对象时，被隐式调用。

## 语法

static{代码}；static可加可不加，分号可加可不加。

## 用途

1. 进行初始化操作，具体表现在：当多个构造器可以抽离出统一的代码时，就可以使用代码块保存起来，从而进行统一的输出（初始化）。（即可以理解为对构造器的补充机制）



## 静态/非静态对比

普通代码块和类加载没有关系，是在创建对象时被调用的，且每创建一次对象就执行一次普通代码块。

静态代码块，**当类加载时就被调用**，且仅最多只能被调用一次静态代码块。

静态代码块中只能调用静态成员。

## 类加载

类加载是在类对象创建之间的操作

1. 当调用静态成员时，类加载
2. 当创建对象时，类加载
3. 当创建子类对象时，父类也会被加载，即父子类都会被加载

## 优先级

类加载-->类信息加载（方法区）（加载方法）--> 类对象加载（堆区）（加载（执行）static变量/代码块。当创建对象后，继续推进-->执行普通变量/代码块-->构造器

## 对于构造器

构造器中第一句默认调用super()，第二句默认调用普通属性/代码块

## 总结

有继承关系时：从父类开始加载；创建对象时，从构造器可知，也是从父类开始进行初始化操作。









# final关键字

final可以修饰类、类成员和局部变量，不可修饰代码块

## 语法

访问修饰符 final ......

## 用途

1. 对于类：不想该类被继承时，可以用final修饰。
2. 对于方法：不想该方法被子类重写时，可以用final修饰。
3. 对于类的属性、局部变量：不想该属性的值被修改，可以用final修饰。

## 细节

1. 被final修饰的属性称为**常量**，此时变量名全部大写字母，且单词之间用下划线隔开。

2. 被final修饰的属性**必须赋初始值**。

    1. 对于非静态：赋值位置可以在声明中、代码块中以及构造器中。
    2. 对于静态：位置在声明中、静态代码块中，不可以在构造器中初始化。

3. 被final修饰的方法只是不能被重写，但是可以被继承。
4. 被final修饰的类中，就没有必要再用final修饰方法了。因为该类不可能被继承，那么也就不可能被重写。
5. 方法中的形参列表中形参可以被final修饰。相当于声明一个被final修饰局部变量。
6. 对于类成员，**final和static往往搭配使用**，效率更高。因为这将不会导致类加载（底层编译器做好的优化）。
7. 包装类（Intege、Double、Boolen...）都是final类，String也是final类。



# 抽象类（abstract关键字）

abstract可以修饰类和方法，其他都不可以

### 语法

访问修饰符 abstract ...

### 用法

当父类的一些方法不确定时，可以用abstract声明该方法。

1. 对于父类：先用abstract修饰父类（这个类就称抽象类）。
2. 对于方法：用abstract修饰方法（这个方法就称抽象方法）。
3. 对于子类：具体重写（实现）这个抽象方法。

### 用途

1. 其实这些方法就是抽离出来的一些共有的、抽象的行为，但是这个行为内部又可以拥有很多的细节（具体子类具体实现）。
2. 在框架和设计模式中用得较多。

### 细节

1. 抽象类无法实例化。
2. 抽象类**不一定**要包含abstract方法。
3. 一旦类中包含了abstract方法，那么这个类也**必须**被abstract修饰。
4. 被abstract修饰的方法不能有方法体（只是声明一个抽象方法）。
5. 如果一个类继承了抽象类，那么这个子类**必须重写**（实现）抽象类中得抽象方法，除非该子类也声明为一个抽象类。
6. 抽象方法都不可以被private、final、static修饰。因为这与重写的语法相违背。







# 接口

## 认识

给出一些没有实现，只有声明的方法，将其封装到一个接口中。当某个类需要使用的这个接口的时候，在根据具体情况重写实现这些方法。

## 语法

创建接口 ：interface 接口名{属性、方法}使用接口：class 类名 implements 接口名 {属性、方法、重写方法}

## 版本问题

jdk8以前，接口内只能是声明方法，不得实现。

jdk8以后，接口内**可以有具体实现的方法**：静态（static修饰符）方法、默认（default修饰符）方法，

#### 接口为什么新增了默认方法和静态方法？

我们的接口老早就写好了，后面因为各种业务问题，避免不了要修改接口。

在Java 8之前，比如要在一个接口中添加一个抽象方法，那所有的接口实现类都要去实现这个方法，不然就会编译错误，而某些实现类根本就不需要实现这个方法也被迫要写一个空实现，改动会非常大。

所以，接口默认方法就是为了解决这个问题，只要在一个接口添加了一个默认方法，所有的实现类就自动继承，不需要改动任何实现类，也不会影响业务。

- 另外，接口默认方法**可以**被接口实现类重写。
- 接口静态方法和默认方法类似，只是接口静态方法**不可以**被接口实现类重写

接口静态方法**只可以**直接通过静态方法所在的接口名.静态方法名来调用。

## 细节

1. 接口不可以实例化

2. 接口中的抽象方法可以不加修饰符直接声明，默认是public abstract。

3. 接口中具体实现的方法必须加访问修饰符（一般是加default）。

4. 属性可以不加修饰符进行定义，必须得赋值，默认是public static final。

5. 抽象类实现（implements）接口，**可以不用**重写接口的抽象方法。

6. 普通类实现（implements）接口，**必须重写**实现接口的抽象方法。

7. 一个类可以**同时实现多个接口**

    语法：class 类名 implements 接口名1,接口名2,......{}

8. 接口不能继承其他类，但是可以**继承接口**。

9. 接口是存在**多继承**的。

    语法：interface 接口名 extends 接口名1,接口名2,......{}

10. 接口的访问修饰符只能是public和默认，和类一样。

## 用途

接口实际上就是封装存放一些公共的、统一的方法。



## VS继承

#### 对java单继承机制的补充

语法：子类名 extends 父类名 implements 接口1,接口2,......

即实现了子类可以超出父类的范围，去拥有其他的行为。

1. 也可以理解为接口内的方法可能是不能被抽离放在父类中的
2. 也可以理解为子类中的方法，可以抽离成好几种类型，分为父类、接口1、接口2、......

#### 价值用法对比

- 继承：解决代码复用性和维护性，更加偏向于实际对象的抽象化

- 接口：声明设计规范（或者行为方法），让其他类来具体实现，更加偏向于对象行为的抽象化

由于接口只需要考虑行为动作，因此接口更加的灵活。

接口在一定程度上也可以实现代码解耦（即通过接口规范性 + 动态绑定机制 ）



## VS多态

接口引用可以指向实现了该类的对象。

如存在一个接口IA，一个类BB实现了IA，那么就有IA ia = new BB();

对于方法中的形参也一样，形参参数为(接口名 变量名)，那么可以入实现了该接口的对象。

对于多态数组也差不多，可以具体看看多态的笔记。

# 内部类

一个类中又完整的嵌套了另一个类，被嵌套的类称为内部类（inner class）；嵌套其他类的类统称为外部类（outer class）。

**<u>内部类可以访问外部类所有成员（静态内部类特殊处理）。</u>**

## 分类

定义在外部类的局部位置上（方法或者代码块中）

1. 局部内部类（有类名）
2. 匿名内部类（无类名）

定义在外部类的成员位置上

1. 成员内部类（无static）
2. 静态内部类（有static）

## 局部内部类

### 细节

1. **优先级/地位属于“局部”**
2. 局部内部类是定义在外部类的局部位置，**通常在方法中**
3. 因为是“局部”所以不能被访问修饰符修饰，但可以用final（不想被其他的内部类继承）
4. 作用域：只在定义它的方法或者代码块中具有作用
5. 如果内部类和外部类的成员重名时，默认遵循就近原则。当想访问外部类的成员时，可以通过：**外部类名.this.成员名** 去访问。（此时this指向的时内部类的对象实例，外部类名.this实际上指向的就是外部类的对象实例）

### 访问关系

- 内部类访问外部类，直接访问，重名时访问外部类，**外部类名.this.成员名** 。
- 外部类访问内部类，创建对象后再访问。
- 外部其他类不能访问内部类，因为属于“局部”。

## 匿名(Anonymous)内部类

### 语法

new 类/接口(参数列表){ 代码 };

### 用法

可隐含多态、继承的用法。（向上转型）（继承方法）（花括号中一般不加构造器）（参数列表一般不填）

接口 变量名 = new 接口() {代码};

类 引用名 = new 类() {代码};

### 底层

实际上，在执行new的时候，底层会做一个操作

1. 创建一个类，该类**继承/实现了一个父类/接口**。（此时底层是会分配一个名字当作类名的，也是就是类型）
2. 其中参数列表会传给构造器
3. 然后再执行花括号{}中的代码
4. 最后返回该对象的地址，令引用名/变量名指向该对象。

此时再回来看上面的用法，可知**一定是一种向上转型**。

此时再讨论编译类型和运行类型，就可以知道，**编译类型是左边的，而运行类型则是由底层分配好的**。因此调用方法时，也遵循了动态绑定机制。

### 用途

对于某个对象，我只需要调用一次。为了防止多创建一个类浪费资源，因此使用匿名内部类。

实际上就是，开发过程中，匿名内部类作为一个参数传入方法中，该方法调用了形参的方法。

如：方法名（new 类/接口(){}）;

具体看下面的总结

### 细节

几乎和局部内部类的细节差不多，但是对于第3点，因为用法的原因，所以没有必要关注修饰符。

### 访问关系

- 内部类访问外部类，直接访问，重名时访问外部类，**外部类名.this.成员名** 。
- 外部类访问内部类，创建对象后再访问。（因为用途的关系，所以基本不存在）
- 外部其他类不能访问内部类，因为属于“局部”。

## 成员内部类

### 细节

1. **优先级属于“类成员”**
2. 无static修饰
3. 可以加任意访问修饰符（public、protected、默认、private）
4. 作用域：属于成员，在类中都存在作用范围

### 访问关系

- 内部类访问外部类，直接访问，重名时访问外部类，**外部类名.this.成员名** 。
- 外部类访问内部类，创建对象后再访问。
- 外部其他类访问内部类：（若只想创建内部类的对象，那么以下的第一步都可以不用引用接收，而是直接匿名创建外部类对象）
    1. 创建外部类对象后，再创建内部类对象。
    2. 创建外部类对象后，再调用外部类中能够**获取内部类对象的方法**

## 静态内部类

### 细节

与成员内部类几乎一致，但对于第2点，静态内部类由static修饰。

**静态内部类不持有指向外部类对象的引用this**

### 访问关系

- 内部类访问外部类，直接访问（仅限静态成员），重名时访问外部类，**外部类名.成员名** 。
- 外部类访问内部类，创建对象后再访问。
- 外部其他类访问内部类：（若只想创建内部类的对象，那么以下的第一步都可以不用引用接收，而是直接匿名创建外部类对象）
    1. 创建外部类对象后，再创建内部类对象。
    2. 创建外部类对象后，再调用外部类中能够**获取内部类对象的<u>静态</u>方法**



## 总结

#### 内部类

作用

1. 每个内部类都能独立的完成一个接口的实现，所以无论外部类是否已经完成了某个（接口）实现，对于内部类都没有影响。内部类使得**多重继承**的解决方案变得完整。
2. 方便将存在一定逻辑关系的类组织在一起，又可以**对外界隐藏**。
3. 方便编写事件驱动程序。
4. 方便编写线程代码。

认识

- 内部类与所在外部类有一定的关系，往往只有该外部类调用此内部类，所以没有必要专门用一个Java文件存放这个类。
- 内部类体现了一种代码的隐藏机制和访问控制机制。
- 调用内部类，内部类才会加载，而无关乎外部类是否加载。除了静态内部类：静态内部类加载，则外部类也一定会被加载。

#### 成员内部类使用场景

1. 不可能有其他类使用该内部类。 
2. 该内部类不能被其他类使用，可能会导致错误。

#### 匿名内部类使用场景

1. 在**编写事件监听的代码**时匿名内部类不但**方便**，而且使代码更加**容易维护**。
2. 匿名内部类的使用范围非常有限，大部分匿名内部类用于**接口回调**。

#### 静态内部类

丧失了多继承的效果。大概只在特定情况会用到。

# 总结关键字常用位置

| 关键字       | 运用位置                                       |
| ------------ | ---------------------------------------------- |
| static       | 成员属性、成员方法、~~接口中的具体的实现方法~~ |
| final        | 类、~~成员属性~~、成员方法、局部变量           |
| abstract     | 类、成员方法                                   |
| default      | 接口中的具体实现方法                           |
| static+final | 成员属性                                       |
| private      | 封装成员属性、~~封装成员方法~~                 |
|              |                                                |
|              |                                                |
|              |                                                |

# 不可变类

为了使类成为不可变，要遵循以下五条原则：

1. 不要提供任何会修改对象状态的方法(set方法)。
2. 保证不会被扩展。（防止子类化，可使用fianl修饰类）
3. 声明所有的属性都是final的。
4. 声明所有的属性都为私有的。
5. 确保对任何可变组件的互斥访问。

不可变类的优点：

1. 不可变对象简单，只有在创建时的一种状态。
2. 不可变对象创建后无需考虑额外的维护工作。
3. 不可变对象本质上是线程安全的，他们不要求同步。
4. 不可变对象可以被自由的共享其本身和内部信息。

> 因不可变对象的这些特性，对于频繁用到的值，尽可能的重复使用现有实例。

# 枚举Enumeration

## 认识

实际上就是在内部创建一个**<u>常量对象</u>**，外界仅能通过给定方式访问这个对象，且不能修改。

枚举类就是可以将一系列具有统一属性、行为的有限个数对象 集中封装到一个类中。

## 自定义类

```java
class TestEnum {
    //常量对象名（引用名）全大写
    //final + static；final修饰为常量，static保证可以用类名直接调用
    public final static TestEnum ENUM1 = new TestEnum();
	private String name;//属性私有
    private TestEnum(){//构造器私有
        
    };
    public void test() {//可提供向外的方法
        //可以是获取对象的方法：get对象名();//但一般不写
        //也可以是一些对象的行为方法：say();
    } 
}
```

## 关键字enum实现枚举类

~~~java
enum TestEnum {
	//开头根据构造器创建常量对象
    //若构造器是无参构造器，则直接写常量名即可
    //若构造器带参，则要填上
    //多个常量对象用逗号隔开
    ENUM1,ENUM2("name1"),ENUM3("name2");
    private String name；//属性私有
    private TestEnum(){//构造器私有
        
    }
    private TestEnum(String name){
        
    }
    public void test(){//可向外提供方法
		//可以是一些对象的行为方法：say();
    }
}
~~~

利用该关键字，实际上在底层是继承了Enum类，因此enum类不可以再继承其他类，但是可以implements其他接口。

在底层中，实现enum类其实和自定义的方法是差不多的。可以反编译查看底层实现的效果。

## 关于Enum类

~~~java
//其中的成员方法，利用enum关键字创建的类可以继承
toString();//返回该常量常量名，常用。String
ordinal();//返回该该常量在创建时的次序。int
compareTo(另一常量);//返回该常量与另一常量的次序偏移量。int

//静态方法
values();//返回一个数组，该数组按ordinal次序排序。引用类型
valueOf(String);//若字符串匹配上常量对象，则返回该对象，否则异常。引用类型
    
//关于相等的比较
可以直接用名字比较，因为这是一个常量对象，只有一份，指向的都是同一个地址
也可以用成员方法：equals()比较,Enum类重写了该方法，比较的也是地址。
~~~



# 注解Annotation

@interface，[注解类](http://www.jasongj.com/2016/01/17/Java1_%E6%B3%A8%E8%A7%A3Annotation/)

## 元注解（了解）

修饰注解的注解，即元注解

@Rentention，指定作用范围（三种）

SOURCE，在编译阶段，即在.java文件中

CLASS，在字节码阶段，即.class文件中

RUNTIME，在运行阶段，即jvm运行时会保留注解，程序可通过反射得到注解。



@Target，指定使用位置

@Documented，指定注解是否在javadoc中体现，即生成文档时，可看见该注解

@Inherited，子类继承父类注解。如果某个类使用了被@inherited修饰的注解，那么它的子类也将具有该注解



## 三种注解

@Override，使用该注解必须重写，否则报错

```java
@Target(ElementType.METHOD)//只用于方法
```

@Deprecated，使用该注解表示某元素已过时，不推荐使用，但仍可以使用。一般用于版本兼容和过渡。

```java
@Target(value={CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, MODULE, PARAMETER, TYPE})//可以用于构造器、子段、变量、方法、包、模块、参数、类型
```

@SuppressWarnings("", "", "")，使用该注解表示抑制某元素报错，可以精准抑制、也可全部抑制，

```java
@Target({TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE, MODULE})//可用于类型、字段、方法、参数、构造器、变量、模块
String[] value();//可以传入多抑制信息。
```

~~~java
/*
    可以指定的警告类型有
    all，抑制所有警告
    boxing，抑制与封装/拆装作业相关的警告
    cast，抑制与强制转型作业相关的警告
    dep-ann，抑制与淘汰注释相关的警告
    deprecation，抑制与淘汰的相关警告
    fallthrough，抑制与 switch 陈述式中遗漏 break 相关的警告
    finally，抑制与未传回 finally 区块相关的警告
    hiding，抑制与隐藏变数的区域变数相关的警告
    incomplete-switch，抑制与 switch 陈述式(enum case)中遗漏项目相关的警告
    javadoc，抑制与 javadoc 相关的警告
    nls，抑制与非 nls 字串文字相关的警告
    null，抑制与空值分析相关的警告
  **rawtypes，抑制与使用 raw 类型相关的警告
    resource，抑制与使用 Closeable 类型的资源相关的警告
    restriction，抑制与使用不建议或禁止参照相关的警告
    serial，抑制与可序列化的类别遗漏 serialVersionUID 栏位相关的警告
    static-access，抑制与静态存取不正确相关的警告
    static-method，抑制与可能宣告为 static 的方法相关的警告
    super，抑制与置换方法相关但不含 super 呼叫的警告
    synthetic-access，抑制与内部类别的存取未最佳化相关的警告
    sync-override，抑制因为置换同步方法而遗漏同步化的警告
  **unchecked，抑制与未检查的作业相关的警告
    unqualified-field-access，抑制与栏位存取不合格相关的警告
  **unused，抑制与未用的程式码及停用的程式码相关的警告
*/
~~~



# 异常Exception

## 认识

程序执行中发生的不正常情况称为异常。

异常可分为两大类：Error和Exception

### Error

jvm无法解决的严重问题。如jvm系统内部崩溃、资源耗尽等。StackOverFlow、out of memory。

### Exception

因编程错误或者外界的一些因素，导致的一般性的问题，此时可以利用针对性的代码解决。

Exception又分为两类：RuntimeException和编译时异常。

#### 运行时异常

编译器检查不出来。一般是编程时出现的逻辑错误。

java.lang.RuntimeException类以及子类都是运行时异常

运行时异常可以不做处理，直接交由jvm处理。因为此类异常很普遍，若全处理会对程序的可读性和运行效率产生影响。

常见的运行时异常：

1. NullPointerException，空指针异常（引用时常见的异常）
2. ArithmeticException，数学运算异常（公式使用常见的异常）
3. ArrayIndexOutOfBoundsException，数组下标越界异常（数组使用时常见的异常）
4. ClassCastException，类型转换异常（转型时常见的异常）
5. NumberFormatException，数字格式异常（当使用包装类的parse成员方法常见的异常）
6. InputMismatchException ，输入不匹配异常（当接收Scanner类的next成员方法常见的异常）

#### 编译时异常

编译器会检查出来，程序员必须处理（try-catch-finally或者throws），否则无法编译。

常见的编译时异常：

1. SQLException，数据库操作异常
2. IOException，文件输入输出异常
3. FileNotFoundException，文件不存在异常
4. ClassNotFoundException，类不存在异常
5. EOFException，文件末尾异常
6. IllegalArguementException，非法参数异常

## 异常处理方式

### try-catch-finally

IDEA快捷键：ctrl + alt + t

执行顺序：

1. try中无异常，则执行try中全部语句，然后跳过catch执行finally的语句
2. try中有异常，则检测到异常时立即中断执行，然后进入catch里的语句，最后执行finally语句

#### try

将可能会出现的代码写进try的代码块中

#### catch

用于捕获异常

**利用异常类中的成员方法：getMessage()可以获取异常信息**。

可以存在多个catch，括号内可以是具体的异常，也可以是某一大类异常。使用即类似于if-else进行判断异常。

其中异常越精确则放置顺序越往前，异常越笼统则放置顺序越靠后（子类异常在前，父类异常在后）。

同辈异常则可以保持任意顺序。

#### finally

常用于关闭连接、释放资源



可以不写finally。

finally的代码必须执行，无论是否出现异常。



#### 关于catch与finally

catch会在退出之前执行finally的语句。

若catch代码块中，退出时要返回一个数据，则jvm会先将这个数据用临时变量保存起来，当执行完finally时再回到catch将这个临时变量内的数据返回。

#### 关于try与finally

相当于没有捕获异常，但是一定会执行finally的语句。



~~~java
    try {
        //可能出现异常的代码
    }
    catch(NullPointerException e) {
        //处理
    }
    catch(ArithmeticException e) {
        //处理
    }
    catch(Exception e) {
        //处理
    }
  /*finally{
		//代码
    }*/


public static void main(String[] args) {
		//如果用户输入的不是一个整数，就提示他反复输入，直到输入一个整数为止
		//思路
		//1. 创建 Scanner 对象
		//2. 使用无限循环，去接收一个输入
		//3. 然后将该输入的值，转成一个 int
		//4. 如果在转换时，抛出异常，说明输入的内容不是一个可以转成 int 的内容
		//5. 如果没有抛出异常，则 break 该循环
		Scanner scanner = new Scanner(System.in);
		int num = 0;
		String inputStr = "";
		while (true) {
			System.out.println("请输入一个整数:"); 
			inputStr = scanner.next();
			try {
				num = Integer.parseInt(inputStr); //这里是可能抛出异常NullPointerException
                //可以不用字符串接收 再解析
                //可以直接num = scanner.nextInt();//也可能会抛出异常InputMismatchException
				break;
			} catch (NumberFormatException e) {
				System.out.println("你输入的不是一个整数:");
			}
		}
		System.out.println("你输入的值是=" + num);
	}
~~~

### throws

如果某方法中可能会出现异常，且不确定如何处理该异常，则此方法应显式地（声明）抛出该异常，表示该方法不对这些异常处理，而由方法的调用者（上一级方法）来处理异常。

抛出的可以是精确的异常，也可以是异常的父类。

可以抛出多个异常，用逗号分隔。

运行异常可以不用处理，则默认throws，但编译异常必须显式地处理，不会默认 throws。

子类重写父类的方法时，对抛出的异常具有规定：子类重写的方法，所抛出的异常类型 要么和父类抛出的异常一致；要么为父类抛出的异常的类型的子类型。



## 自定义异常

当自定义异常类继承RuntimeException时，为运行时异常；继承Exception时，为编译时异常。

一般情况下，我们自定义异常是继承 RuntimeException，即把自定义异常做成 运行时异常，好处是，我们可以使用默认的处理机制，即比较方便。

~~~java
//创建语法
class AgeException extends RuntimeException {
	public AgeException(String message) {//构造器
		super(message);
	}
}

//具体使用（抛出自定义异常）：throw new AgeException("年龄需要在 18~120 之间");//创建的对象也可以是已有的异常类，然后再重新写入自己想要夫人异常信息
~~~



## throws与throw

| 关键字 | 意义                     | 位置       | 后面跟着的东西 |
| ------ | ------------------------ | ---------- | -------------- |
| throws | 处理异常的方式           | 方法声明中 | 异常类型       |
| throw  | 手动生成异常对象的关键字 | 方法体中   | 异常对象       |
