

# 基础认识

程序：完成任务，用某语言编写的一组指令集合。

进程：运行中的程序。是一个动态过程：有产生、存在和消亡的过程。

线程：由进程创建，是进程的一个实体。

一个进程可拥有多个线程。

单线程：同一时刻，只允许执行一个线程。

多线程：同一时刻，可以执行多个线程。

并发：同一时刻，多个任务交替执行。如单核cpu。

并行：同一时刻，多个任务同时执行，如多核cpu。



# 线程优缺点

线程优点：

1. 一个进程中可以同时存在多个线程。
2. 各个线程之间可以共享地址空间和文件等资源（**堆内存和方法区内存共享**）
3. **一个线程一个栈。栈内存是独立的。**（故可以在各自的栈上并发执行）
4. 各个线程之间可以并发的执行。

线程缺点：

1. 一个线程崩溃，会导致其所属进程的所有线程崩溃

线程与进程的区别：

1. 进程是资源分配单位，线程是CPU调度单位
2. 进程拥有一个完整的资源平台，而线程只独享指令流执行的必要资源，如寄存器和栈
3. 线程具有就绪，等待和运行三种基本状态和状态间转换关系
4. 时空：
    1. 线程能减少并发执行的时间和空间开销：
    2. 线程的创建时间比进程短；
    3. 线程的终止时间比进程短；
    4. 同一进程内的线程切换时间比进程短；
5. 由于同一进程的各线程间共享内存各文件资源，可以不通过内核进行直接通信
   

# 线程状态（重点！！）

![](https://img-blog.csdnimg.cn/d9adb825ead94cb9a83861da8745b361.png)

状态：

1. NEW，新建线程状态，未调用start()方法
2. RUNNABLE，可执行状态，有机会被CPU调用
    1. READY，就绪状态，等待被CPU调用
    2. RUNNING，运行状态，正在被CPU调用
3. TIMEDWAITNG，定时等待，指定时间后进入RUNNABLE，可提前中断或通知
4. WAITING，无限等待，直到中断或通知
5. BLOCKED，等待争夺锁，不可中断
6. TERMINATED，结束线程

# 线程调度模型

1. 抢占式：优先级高，抢到cpu时间片的概率就高
2. 分布式：平均分配cpu时间片

## java中关于调度有关的方法

java是抢占式调度模型

最低优先级为1，默认为5，最高为10

~~~java
// 获取优先级
void setPriority(int);
int getPriority();
~~~



# 开启线程

1. 继承Thread类，重写run方法，调用Thread类的start()方法
2. 实现Runnable接口，重写run方法，调用Thread类的start()方法
3. 实现Callable接口，重写带返回值的call方法，调用Thread类的start()方法

- **底层都是调用`start0()`方法，该方法由jvm调用。**

- 调用start0()方法后也不是立马执行，而是变为可运行状态，具体执行的时间，根据操作系，由cpu统一调度。

- run方法中，不可以抛出任何异常，只能捕获解决，因为父类没有抛出任何异常。

## Thread

~~~java
class A extends Thread {
    @Override
    public void run() {
        //代码...
    }
}
class M {
    public static void main() {
        // 创建线程对象
        A a = new A();
        // 开启线程
        a.start();//该start方法是Thread类中的方法
        //a.start();//不能再次在同一对象的线程执行过程中，再创建一个线程。
        A aa = new A();
        aa.start();//可以再创建一个对象，去执行另一个线程
    }
}
~~~

## Runnable

~~~~java
class A implements Runnable{
    @Override
    public void run() {
        //代码...
    }
}
class M {
    public static void main() {
        // 创建一个可运行的对象
        A a = new A();
        
        // 将对象封装成线程对象
        Thread t1 = new Thread(a);
        Thread t2 = new Thread(a);
        
        //t1和t2是两个不同的对象，可以创建两个线程，同时调用的又都是a的run方法，即实时共享数据。
        t1.start();
        t2.start();
        
        // 一般可以直接创建，因为目的是获取线程对象。
        Thread t3 = new Thread(new A()); // 这种形式还可以使用匿名内部类的形式来重写run方法，避免了再新建一个类
        t3.start();
    }
}
~~~~

## 匿名内部类开启线程

~~~java
class M {
    public static void main() { 
        Thread t1 = new Thread(new Runnable() {
            // ......
        }); // 这种形式还可以使用匿名内部类的形式来重写run方法，避免了再新建一个类
        t1.start();
    }
}
~~~

## Callable

~~~java
class A implements Callable<String> {
    @Override
    public String call() {
        //代码
        return "返回值";
    }
}
public class M {
    //FutureTask类实现了
    public static void main(String[] args) {
        // 创建可运行的对象
        A a = new A();
        // 包装可运行的对象
        FutureTask<String> t1 = new FutureTask<>(a);
        // 创建线程对象，并启动线程
        new Thread(t1, "线程一").start();
        // 得到返回值
        System.out.println("线程的返回值：" + t1.get());// 会阻塞当前线程
    }
}
~~~



## Thread类与接口区别

本质上是没有区别的，但是用法有区别。

- 实现Runnable接口更加适合多线程共享一个资源的情况。且可以避免单继承的限制。

- 继承Thread类想实现多线程共享一个资源的话，就需要配合static达到共享的目的。

Runnable创建线程，实际上用到了静态代理模式。即实际上是将创建线程的任务，通过Thread类中的start()方法去调用start0()方法完成的。

## Runnable与[Callable](http://t.csdn.cn/7kaZA)区别

1. 最大的区别，runnable没有返回值，而实现callable接口的任务线程能返回执行结果
2. callable接口实现类中的run方法允许异常向上抛出，可以在内部处理，try catch，但是runnable接口实现类中run方法的异常必须在内部处理，不能抛出
3. Callable中get()方法会阻塞其他线程，具体看源码。

~~~java
import java.util.concurrent.ExecutionException;
import java.util.concurrent.FutureTask;
import java.util.concurrent.Callable;
public class CallableTest implements Callable<String> {
    private String string;
    public CallableTest(String string) {
        this.string = string;
    }

    @Override
    public String call() throws Exception {
        //任务阻塞5秒，异常向上抛出
        Thread.sleep(5000);
        return this.string;
    }
//    异常也可以try catch解决
//    @Override
//    public String call(){
//        //任务阻塞5秒  异常向上抛出
//        try {
//            Thread.sleep(5000);
//        } catch (InterruptedException e) {
//            e.printStackTrace();
//        }
//        return this.string;
//    }
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        Callable<String> callable = new CallableTest("my callable is ok!");
        FutureTask<String> task = new FutureTask<String>(callable);
        long beginTime = System.currentTimeMillis();
        //创建线程
        new Thread(task).start();
        //调用get()方法阻塞主线程
        String str = task.get();
        long endTime = System.currentTimeMillis();
        System.out.println("hello :"+ str);
        System.out.println("time :"+ (endTime - beginTime)/1000);
    }
}
~~~



# 线程常用方法

| 方法（普通）          | 作用                                                        |
| --------------------- | ----------------------------------------------------------- |
| currentThread()//静态 | 获取当前线程                                                |
|                       |                                                             |
| setName(String)       | 设置线程名字                                                |
| getName()             | 获取线程名字，默认时为：Thread-0，Thread-1，...             |
|                       |                                                             |
| run()                 | 调用重写的run()方法                                         |
| start()               | 调用线程                                                    |
|                       |                                                             |
| setPriority(int)      | 设置优先级                                                  |
| getPriority()         | 获取优先级                                                  |
|                       |                                                             |
| sleep(long)//静态     | 休眠，毫秒为单位。让当前线程进入TIMEDWAITNG，会占用cpu资源  |
| interrupt()           | 中断休眠                                                    |
|                       |                                                             |
| yield()//静态         | 线程让出cpu。线程会回到READY。不一定成功，由cpu紧张程度决定 |
| join()                | 线程插入，抢占cpu。直到该线程执行完才能去执行其他线程。     |
|                       |                                                             |

Thread.sleep()和Thread.yield()不会暂停线程执行，不会释放锁。

# 安全终止线程的操作

在线程类中做标记，在另一线程中执行某事件时，使改动标记，使得线程停止。

~~~java
class A implements Runnable{
    boolean flag = true;
    @Override
    public void run() {
        //代码...
        if (flag) {
            // ...
        }
        else {// 当标记为false时，停止线程
            // ...保存数据、关闭资源等等
            return;
        }
    }
}
class M {
    public static void main() {
        Thread t1 = new Thread(new A()); 
        t1.start();
        t1.flag = false;
    }
}
~~~



# 多线程安全问题

## 不安全的条件

1. 多线程并发时
2. 且操作共享数据时

## 解决安全问题

线程同步机制：使线程无法并发，而是排队执行。

##  关于同步机制的使用时机

为了用户体验好，不应该直接选择同步机制，因为排队效率低。

1. 尽量使用局部变量代替实例变量和静态变量，从而避免线程问题
2. 若只能是实例变量，那么就考虑创建多个实例变量，让不同线程区获取不同实例变量的数据，从而避免线程问题
3. 如果以上两种方式都无法适用，那只能使用同步机制了

# 同步机制的实现

## Synchronized关键字

线程同步：当一个线程在对内存操作时，其他线程都不能在这个内存进行操作，而是进入BLOCKED状态，直到第一个线程完成操作。

使用方法：

~~~java
//1. 同步代码块
synchronized (对象) {}// ()内一般都是填this，因为要针对某些线程共享数据来上锁，而不是针对所有线程上锁。this是实例对象。并不是所有线程都会拿到这份数据。

//2. 同步方法（不常用）
public synchronized void methon() {}// 该方法，上锁的一定是this，也就是当前实例
~~~

## 互斥锁

1. 每个对象都有一个对应的互斥锁标记
2. synchronized关键字来与对象的互斥锁联系。当对象被synchronized修饰后，即上锁
3. 局限：会降低效率。
4. 同步时，若也被static修饰，则联系的对象是对应类的class对象，即类名.class。
5. 同步时，若不被static修饰，则联系的对象默认是实例化的对象，即this。

### 使用的重点

1. 在多线程时，保证**上锁的代码关联的是同一个对象**。
2. 因此实现Runnable接口，并用**带参构造线程来创建多线程（参数为同一对象）**就可以保证多线程操作的是同一个对象。
3. 而用继承Thread类，来创建多线程，一般是不会联系到同一对象的。除非在用static来保证共享资源的同时，其中上锁的对象也是static的，这样就可以保证每次联系的是同一对象。



### 推荐使用

同步代码块（作用范围小，维护方便）+Runnable接口（可共享资源）



## 释放锁

1. 线程中的同步方法、同步代码块执行完毕时

2. 提前退出同步方法、同步代码块

    1. 出现了未处理的异常
    2. 可能的break和return

3. 在同步方法、同步代码块中执行了线程对象的wait()方法，使当前线程暂停，并释放锁。



# ThreadLocal

## 认识

本质上就是一个Map集合，K是当前线程，V数据类型是泛型，具体值可以自行传入。

## 作用

对当前线程绑定数据（当前线程共享数据）。

若V不是集合，那么一个线程只能绑定一个数据；

反之，可以将绑定的数据都放到集合中，使得可以绑定多个数据

## 方法

其中三个方法最重要

~~~java
// 先创建ThreadLocal
ThreadLocal<...> threadLocal = new ThreadLocal<>();

threadLocal.set(T value);// 对当前线程绑定一个value数据
... t = get();// 获取当前线程的绑定数据
threadLocal.remove();// 删除当前线程的绑定数据
~~~

## 示例

用于JdbcUtils

~~~java
// 创建
private static ThreadLocal<Connection> threadLocal = new ThreadLocal<>();

public static Connection getConnection() {
    Connection connection = null;
    try {
        if (threadLocal.get() == null) {
            threadLocal.set(DriverManager.getConnection(url, user, password));
        }
    } catch (SQLException e) {
        throw new RuntimeException(e);
    }
    return threadLocal.get();
}

public static void close(ResultSet res, Statement statement, Connection connection) {
    try {
        if(res != null) {
            res.close();
        }
        if(statement != null) {
            statement.close();
        }
        if(connection != null) {
            // 在线程池中，多个线程存在重复使用的情况，故线程销毁时，一定要将TreadLocal里的值remove掉。
            if (threadLocal.get() != null) {
                threadLocal.remove();
            }
            connection.close();
        }
    } catch (SQLException e) {
        throw new RuntimeException(e);
    }
}
~~~

# 工作线程与守护线程

工作线程也称用户线程。当任务执行完或者以通知方式来结束。

守护线程：

1. 一般是个死循环，一直执行。
2. 一般为工作线程服务，当所有的工作线程结束时，守护线程自动结束。
3. 一般用于监控其他线程，方便管理多线程。
4. 常见的守护线程就是垃圾回收机制。

使用方式：在线程启动前设置为守护线程。

~~~java
t1.setDaemon(true);
t1.start();
~~~



# 定时器

位于java.util.Timer下，Timer实现了Runnale，实际上就是一个线程

~~~java
// 创建
Timer timer = new Timer();
Timer timer = new Timer(true);// 设置为守护线程

// 指定定时任务
timer.schedule(TimerTask task, Date firstTime, long period);// task – 要安排的任务。 firstTime – 第一次执行时间。 period – 间隔多久时间执行一次（以毫秒为单位）
~~~

## 使用

~~~java
class Main {
    public static void main(String[] args) throws Exception{
        // 创建定时器对象
        Timer timer = new Timer();
        
        // 指定格式
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        Date date = sdf.parse(String.valueOf(System.currentTimeMillis()));
       // 指定定时任务
        timer.schedule(new hello(), date, 1000 * 10);
    }
}
class hello extends TimerTask {
    @Override
    public void run() {
        // ...
    }
}
~~~

# wait方法和notify方法

是Object类下的方法。

- 两方法应建立在线程同步基础之上来使用。因为要保证某个线程处于BLOCKED状态而不是RUNNABLE状态，这样才能避免所有线程都进入等待状态而出现死锁。

1. obj.wait()：让obj对象上的Runnale状态的线程都进入 等待状态，直到被唤醒。并会释放obj对象的锁
2. obj.nofity()/notifyAll()：让obj对象上处于 等待状态的线程进入RUNNABLE状态。不会释放obj对象的锁
    1. notify随机唤醒一个
    2. notifyAll全部唤醒


生产者消费者模式

~~~java
class A implements Runnable {
    private List list;
    public A(List list) {
        this.list = list;
    }
    @Override
    public void run() {
        while(true) {
            Synchronized(list) {
                if (list.size() > 0) {
                    list.wait();    
                }
                list.notify();
            }
        }
    }
}
class B implements Runnable {
    private List list;
    public B(List list) {
        this.list = list;
    }
    @Override
    public void run() {
        while(true) {
            Synchronized(list) {
                if (list.size() == 0) {
                    list.wait();    
                }
                list.notify();
            }
        }
    }
}
~~~

1. 此模式中，所有线程都共享着一个list数据
2. 所有线程都持有着同一把锁list，
    1. 故线程的BLOCKED状态取决于该把锁
    2. 且易知，大部分时间线程都是处于，一个线程是RUNNABLE而其他线程都是BLOCKED的进程中
3. 因此在这样的进程中使用wait，始终只会令仅仅一个线程进入等待状态。
    1. 使用wait方法后，进程变为了：一个线程是等待状态，而其他线程是RUNNABLE状态开始争夺锁资源。
4. 当争夺完毕后，进程变为了：一个线程是等待、一个是RUNNABLE、其他都是BLOCKED。
5. 其中一个线程可能会一直处于等待状态，而其他线程处于RUNNABLE（只一个线程）和BLOCKED轮换的情况。
6. 但是最终，RUNNABLE线程在执行到某个时机时，一定会调用notify方法，令等待中的线程转变为RUNNABLE，又因为拿不到锁，最终去到BLOCKED状态。
    1. 此时进程为：一个RUNNABLE、其他BLOCKED。
7. 最后回到第2点继续执行。
