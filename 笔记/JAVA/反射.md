反射，[动态代理](https://juejin.cn/post/6911549491158089742?share_token=893fa252-bc2a-48e7-a9c7-b8e074f0760d)，aop面向切面编程（设计思想），[ioc控制反转](https://juejin.cn/post/6844903679393284104?share_token=bdac5887-5f54-4450-b709-c3c63af554a2)（设计思想），di依赖倒置

## 反射功能

1. 运行时判断一个对象所属类
2. 运行时构造一个类的对象
3. 运行时得到一个类的成员属性和方法
4. 运行时调用一个类的成员属性和方法
5. 生成动态代理



## 反射中的主要类

1. java.lang.Class：代表一个类，Class对象表示一个类被加载后在堆中的对象
2. java.lang.reflect.Method：代表类的方法，Methon对象表示一个类的方法
3. java.lang.reflect.Field：代表类的字段（属性），Field对象表示一个类的属性
4. java.lang.reflect.Constructor：代表类的构造器，Constructor对象表示一个类的构造器



## 用法

通过配置文件 + 反射，在不修改源码的情况下，来控制程序。（开闭原则）

~~~java

Properties p = new Properties();//创建操作配置文件对象
p.load(new FileInputStream("re.properties"));//加载指定配置文件
String className = p.getProperty(classPath);//获取配置文件中的类路径
String method = p,getProperty(method);//类方法
String field = p.getProperty(field);//类字段
//String constructor = p.getProperty(Constructor);//类构造器

Class classInstance = Class.forName(className);//通过Class类的静态方法 创建配置文件中类 的类对象
//通过类对象创建方法对象、字段对象、构造器对象
Method methodInstance = classInstance.getMethod(method);
Field fieldInstance = classInstance.getField(field);
Constructor constructorInstance = classINstance.getConstructor(参数);

Object obj = classInstance.newInstance();//通过类对象 创建对应类的实例（向上转型）

methodInstance.invoke(obj);//通过方法对象 调用 类的成员方法
fieldInstance.get(obj);//通过字段对象 获取 类的成员属性

~~~



## 优缺点

优点：动态的创建和使用对象

缺点：解释执行、对执行速度有影响



## 类加载

静态加载：编译时加载相关的类。如果不存在该类则报错。依赖性强。

动态加载：运行时加载需要的类。如果运行时不需要该类，即使不存在该类也不会报错。降低依赖性。

类加载的时机：

1. new对象实例时
2. 子类加载时，父类也加载
3. 调用类中静态成员时，该类也加载
4. 运行反射（唯一一个可实现动态加载）

### 类加载流程

1. .java源文件通过javac编译为.class字节码文件
2. .class字节码文件通过java运行
3. 运行后首先进行类加载
    1. 第一步，加载Loading。即通过类加载器ClassLoader从不同数据源将字节码文件读入内存，并创建一个java.lang.class对象。（类加载器会获取该Class类对象作为锁，从而保证线程安全）
    2. 第二步，连接Linking。即将类的二进制文件合并到JRE中
        1. 分为验证Verification。验证字节流数据中包含的信息符合jvm的要求，且不会危害jvm安全。
            1. 文件格式验证
            2. 元数据验证
            3. 字节码验证
            4. 符号引用验证
        2. 准备Preparation。对静态变量分配内存（方法区）并默认初始化。常量（static final）与此无关
        3. 解析Resolution。将常量池中的符号引用替换为直接引用。
    3. 第三步。即由jvm对类进行初始化。主要针对静态成员。执行<clinit>()方法，根据源代码中语句的执行顺序，依次收集类中所有静态变量的赋值操作和静态代码块中的语句，进行合并。该方法会保证多线程环境下正确的加锁和同步。





## Class类

1. 也是Object的子类
2. 由系统创建（ClassLoader）
3. 某个类的Class类对象只会在内存中存在一份，因为类只会加载一次
4. 每一个类的实例都会记得自己是由哪一个Class类对象生成的
5. 可以通过Class类对象中一系列的API获得完整的类结构
6. Class类对象放在堆区
7. 类的字节码二进制数据在方法区中。包括方法代码、变量名、方法名、访问权限等



## 获取Class对象的方式

~~~java
//需要全类名。利用静态方法。
//一般用于配置文件（编译阶段），即配合Properties获得类名，以及其他操作
Class cls = Class.forName(String name);

//已知具体的类，用类名获取。
//用于参数传递（加载阶段），例如通过反射得到对应的构造器对象(getConstructor(String.class));
Class cls = Cat.class;//安全可靠，性能高

//已知对象实例，用getClass()获取
//用于运行阶段，主要目的是为了获取Class类对象
Class cls = 实例.getClass();

//通过类加载器获取
//第一步先获取类加载器(获取类对象，再通过类对象获取类加载器)
ClassLoader loader = 实例.getClass().getClassLoader();
//第二步再获取类对象(这一步是主要步骤)
Class cls = loader.loadClass(String name);//传入全类名

//基本数据类型获取Class类对象
Class<Integeer> cls = int.class;//(自动装拆箱)
//包装类获取Class对象
Class cls = Integer.TYPE;
~~~



## 哪些类型具有Class类对象

1. 外部类、四种内部类
2. 接口
3. 数组
4. 枚举
5. 注解
6. 基本数据类型
7. void

## Class常用方法

java.lang.Class

~~~java
Class.forName(String name);//通过指定类名，返回对应class对象
newInstance();//普通方法，返回Class对象的一个实例（即通过反射创建对象）

getName();//普通方法，返回Class对象 所代表的实体（类、接口、数组...） 的全类名
getSimpleName();//获取简单类名
getPackage();//以Package形式返回包信息
getSuperClass();//以Class形式返回父类信息
getInterfaces();//以Class[]形式返回接口信息
getAnnotations();//以Annotation[]的形式返回注解信息

//以下都六种方法都是以数组形式返回
getFields();//获取所有public的字段，包括父类
getDeclaredFields();//获取本类所有字符

getMethods();//获取所有public的方法，包括父类
getDeclaredMethods();//获取本类所有方法

getCOnstructors();//获取本类所有的public的构造器
getDeclaredConstructors();//获取本类所有构造器

/*对应上面六种方法，如果最后都不加s，那么就需要传入参数，来获取指定的对象*/

//获得指定的对象
getConstructor(Class<?>... parameterTypes);//通过指定 参数的class对象 返回 对应Constructor对象
getMethod(String name, Class<?>... parameterTypes);//通过指定方法名 以及 参数的class对象 返回 对应Method对象

getClassLoader();//普通方法，返回该类的类加载器
~~~

## Field常用方法

java.lang.reflect.Field

~~~java
getModifiers();//返回int数值，【默认修饰符：0；public：1；protected：4；private：2；static：8；final：16。多种修饰符修饰，则数值相加】
getType();//以Class形式 返回类型
getName();//返回属性名

set(Object obj, Object value);//obj是实例，value是修改的值。当该字段是static时，obj可为null
get(Object obj);//obj是实例，返回对应的值。当字段是static时，obj可为null
~~~

## Method常用方法

java.lang.reflect.Method

~~~java
getModifiers();

getReturnType();//以Class形式 返回 方法的返回类型
getParameterTypes();//以Class[] 返回 参数类型数组
getName();//返回方法名

invoke(Object obj, Object... args);//obj是实例，args是传入的实参。当方法为static时，obj可为null
~~~

## Constructor常用方法

java.lang.reflect.Constructor

~~~java
getModifiers();

getParameterTypes();//以Class[] 返回 构造器参数类型数组
getName();//返回构造器名（全类名）

newInstance(Object... initargs)//initargs是初始化数组
~~~



## 通过反射获取实例的方法

~~~java
//1.通过Class对象
Class cls = Class.forName(String name);//先获取对应类的Class对象
Object obj = cls.newInstance();//然后可以通过该类的无参构造器获取该类的实例

//2.通过Constructor对象
Class cls = Class.forName(String name);//同理先获取该类的Class对象
Constructor cst = cls.getConstructor(Class<?>... parameterTypes);//然后通过指定的参数类型获取构造器对象
Object obj =  cst.newInstance(Object... initargs);//然后可以对构造器传入实参创建实例
~~~

## 爆破

通过反射，可以访问private成员

Field、Method和Constructor都继承了AccessibleObject 类，其中方法：`setAccessible(boolean);`当true时，可以访问私有成员。











