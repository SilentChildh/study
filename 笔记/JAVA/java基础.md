## 变量

char内存大小为2个字节，可以存放汉字

short、byte、char之间不会自动转换。

short、byte、char在进行计算的时候，先转化为int类型计算。

其他基本数据类型之间的计算时，先转换为表达式中数据精度最大的来计算。

String可以运用在switch中来当作判断

### 运算符

```java
byte a = 100;
a += 20;//实际上是， a = a + 20;且隐式的运用了强制类型转换(byte)(a + 20);


true?1:3d;//输出的是1.0，因为三元运算符应当作一个整体，因此优先级会上升。
```

## 编码

asc||只有128个字符，一个字符用1个字节保存。

unicode是万国码，任意一个字符都用2个字节进行保存。拥有局限，即浪费空间或者空间不足的情况。

utf-8是unicode的优化版。是一种动态的编码，一个字符可以利用一到六个字节来进行保存。英文字母为1字节，汉字为3字节

## 类和对象内存分配



![png](https://raw.githubusercontent.com/SilentChildh/PicGo-img-bed/master/202301121150069.png)



----



## 可变参数

可变参数实质就是数组。

当我们传入的是多个同类型的实参变量时：首先，假设可变参数是int... num,当执行该方法时，在栈区开辟空间，然后在这个空间内声明一个变量num（即数组名），该空间保存的是指向堆区的一个地址，在堆区的这个地方，开辟了传入参数对应大小的空间，并将传入参数的值赋给这些空间保存下来。

普通的可变参数(int... num)可以传入数组或者多种同类型数据，传入的是一个指向堆区的地址。

普通的可变参数（int... num），可以用数组的形式来访问数据。

即普通的可变参数可以当作一维数组来处理。

可通过这样：int[]... num来传入二维数组。

---



## 修饰符（public、private、默认、protected）与变量

全局变量可使用修饰符，局部变量不可使用修饰符。



----



## 构造器

![img](C:/Users/silent_child/AppData/Roaming/Typora/typora-user-images/image-20230107174941346.png)



----



## this细节

this指向的就是一个具体的对象，可以理解为是一个引用。

![png](https://raw.githubusercontent.com/SilentChildh/PicGo-img-bed/master/202301121155633.png)



----









----



## 访问修饰符（以访问权限最多为准）

~~public谁都可以访问，private谁都不可以访问~~

### 运用方式

public：它往往用于对外的情况，也就是对象或类对外的一种接口的形式。

protected：它的含义在于子类可以用它修饰的成员，其他的不可以，它相当于传递给子类的一种继承的东西。

default：它是针对本包访问而设计的，任何处于本包下的类、接口、异常等，都可以相互访问。

private：大多数的成员变量都是修饰符为private的，它们不希望被其他任何外部的类访问。（封装的体现）

### 表格

| 访问级别        | 访问修饰符 | 同类 | 同包 | 子类 | 不同包 |
| --------------- | ---------- | :--: | :--: | :--: | :----: |
| 公开            | public     | √    |   √   | √    | √     |
| 受保护          | protected  |    √  | √    |   √   |  ×      |
| 默认（default） | 无         |   √   | √    |   ×   | × |
| 私有            | private    |   √   | × |   ×   | × |

1. 修饰符可以用来修饰成员变量、成员方法、类
2. 只有默认和public可以修饰类（每一个.java文件中最多只能存在一个public的类，且该public类是该.java的文件名）。
3. 对于protected同包中可以看做是public，异包中可以看做private。（尽管是异包，但若是继承关系，那么protected也看做public。也就是从不同包转为了子类的关系，那么就可以拥有访问权了）
4. 实际上可以这么理解：**<u>访问权限是以最多的为准</u>**。例如：
   1. 不同包之间也可以为继承关系（子类），此时访问权限只有public和protected的成员；
   2. 但如果是同包之间的继承关系，那么此时就有public、protected和默认的访问权限。


### 注意

一个java文件可以存在多个类，那么实际上这些类就都可以算作是在同一包下。

**<u>同一java文件下/同一个包下</u>**的所有类之间肯定可以互相调用。

子类对于访问修饰符重点在于父子关系，否则视为正常的一个类来看待修饰符即可。（在作为<u>**子类且同包**</u>的情况下，我们只需要关注父类中那些被private修饰的属性/方法）。

**Java的访问控制是停留在**编译层的**，也就是它**不会在.class文件中留下任何的痕迹，只在编译的时候进行访问控制的检查。其实，通过反射的手段，是可以访问任何包下任何类中的成员，例如，访问类的私有成员也是可能的。

### 总结

故当我们考虑访问权限的时候，我们只需要注意三件事情：

1. 是否都是在当前类（先不考虑子类）下调用；同类下操作无论被什么修饰都可以访问（不考虑static之类的）。
2. 是否在当前包下调用（导入后调用）；在包之间操作时，注意类是否是public。
3. 当前类是否为子类；继承一般都在同一包下操作，故重点关注类中的成员访问权限，即成员是否是privat。



----



## 封装Encapsulation

### 好处

1. 隐藏实现细节
2. 可以对数据进行验证，保证数据安全合理

封装讲明白点其实就是将客观事物抽象出来为一个模板，将抽象出来的数据和行为封装到一个类里面，数据被保护在了内部（安全性），不允许外部程序直接变更数据，只允许通过给定的方法对内部信息进行访问和操作。
相当于机箱而言，他里面的硬件的代码是厂商是自己写好了，硬件间的联系也是通过给定接口进行互通的。计算机也需要一个机箱把各种配件封装进去，如主板、CPU、内存、显卡、硬盘等。一方面，机箱起到保护作用，防止异物（如昆虫）进入内部而破坏电路；另一方面，机箱也不是完全封闭的，它一定对外预留有一些访问接口，如开机按钮、USB接口等，这样用户才能够使用计算机

封装好的类对于我们而言可以看成黑箱，我们不知道他内部具体的实现细节和运转机制，我们只能访问暴露出来的属性和方法。但是封装过度也是存在着问题的 如果把不相干的对象，属性封装在一起，会变得更加难以维护

一个类应该是属性和方法合理有效地封装在一块

封装确实是为了高内聚低耦合

### 实现步骤

1. 将属性进行私有化（private只有允许在当前类下访问，故外界要访问到该属性，**<u>必须</u>**通过其他方式，即可访问的方法（一般来说是public修饰的方法）来对其这些属性进行操作）

2. 提供一个公共的set()方法，用于对属性进行判断并赋值

   ```java
   public void setXxx(类型 参数名， ...) {//Xxx表示某个属性
   	//设置验证数据的业务逻辑
       //设置验证访问权限的业务逻辑
       
       //符合则：成员属性 = 参数
   }
   ```

   <u>**可将set()方法写入构造器中，从而达到封装的效果（访问权限受限、数据验证）**</u>

   构造器一般选择构造所有属性。

3. 提供一个公共的get()方法，用于获取属性的值

   ```java
   public 方法类型 getXxx() {//Xxx表示某个属性
   	//设置验证访问权限的业务逻辑
       
      
       return xx；//符合则返回
   }
   ```

-----



## 继承Extends

### 用途

子类是在父类的基础上创建的，可以拥有父类的成员。这样保证了各个对象的层级可以从大到小不断细分。

**最好层级不要过多，否则代码可读性和可拓展性会降低，提高维护成本。**

### 好处

1. 提高代码复用性，减少代码冗杂
2. 提高代码扩展性和维护性。

### 基本语法

```java
class 子类名 extends 父类名{
		
}
```

### 特点

1. 子类会自动拥有父类的所有属性和所有方法
2. 父类又叫做超类、基类
3. 子类又叫做派生类

### 使用方法

父类写共有属性/方法。

子类写特有属性/方法。

### 继承需要关注的细节

1. 父类的**<u>私有属性/方法</u>**不能在子类中进行直接访问，但可以通过一些公有方法进行间接访问。
2. 关于构造器：
   1. 在创建子类对象，并调用子类的构造器（不管哪种构造器）时，同时也会调用父类的构造器。
   2. 对于父类的构造器：
      1. 默认无参构造器（因为子类的构造器中默认存在super();而这句话会调用父类的无参构造器）
      2. 如果没有无参构造器，那么必须在子类中利用super()指定父类的构造器来为父类的属性进行初始化。
   3. 子类需要指定父类的初始化方法时，可以在子类构造器中利用super(参数);来调用指定的父类构造器.
   4. super(参数)和this(参数)都只能放在构造器的第一行，且至多存在一个，即不能同时出现super()和this().
   5. super()只能在构造器中使用.

3. 所有的类都是Object的子类.
4. java是单继承机制，子类最多只能继承一个父类。
5. 在同一包下，所创建的类**<u>除了私有都可以进行继承</u>**。在继承中，私有成员无法被继承，子类无法使用父类的私有成员。
6. 继承一般都在同一包下操作，故重点关注类中的成员访问权限，即成员是否是privat。

### 继承的内存分布

#### 图表

![image-20230108011649501](https://raw.githubusercontent.com/SilentChildh/PicGo-img-bed/master/202301121158912.png)

如果Father里的age是private，即使GrandPa里也有age，是public，访问age的时候一样到Father就会停止，不会继续查看GrandPa里是否有age。

##### 按照查找关系来返回信息：

对于属性：

1. 首先看子类是否有该属性 
2. 如果子类有这个属性，并且可以访问，则返回信息 
3. 如果子类没有这个属性，就看父类有没有这个属性(如果父类有该属性，并且可以访问，就返回信息..) 
4. 如果父类没有就按照(3)的规则，继续找上级父类，直到 Object...

对于方法：

1. 首先看子类是否有该方法
2. 如果子类有这个方法，且可以调用，则调用
3. 如果子类没有这个方法，就看父类有没有这个方法（如果父类有这个方法，且可以调用（当被private修饰时不可调用），则调用）
4. 如果父类没有这个方法，那么就按照（3）的规则，继续找上级父类，直到Object...

----



## super

### 基本语法

与this基本一致，用于访问父类的属性/方法和构造器。

当属性和方法为私有时无法访问；构造器的用法与this一致，细节已在继承部分提到。

### 按照查找关系来返回信息：

对于属性：

1. 首先看子类是否有该属性 
2. 如果子类有这个属性，并且可以访问，则返回信息 
3. 如果子类没有这个属性，就看父类有没有这个属性(如果父类有该属性，并且可以访问，就返回信息..) 
4. 如果父类没有就按照(3)的规则，继续找上级父类，直到 Object...

对于方法：

1. 首先看子类是否有该方法
2. 如果子类有这个方法，且可以调用，则调用
3. 如果子类没有这个方法，就看父类有没有这个方法（如果父类有这个方法，且可以调用（当被private修饰时不可调用），则调用）
4. 如果父类没有这个方法，那么就按照（3）的规则，继续找上级父类，直到Object...

### 好处

1. 对于构造器：分工明确，由各自类的构造器来进行属性的初始化（即子类属性由子类的构造器初始化，父类属性由父类构造器初始化）。
2. 可访问父类的成员/方法。

### 细节

1. 当父子类中的成员（属性/方法）有重名时，为了访问父类的成员，必须通过super。
2. 如果父子类中的成员不重名，则用this和成员名直接访问是一样的；而对于super则是直接从父类开始查找访问（即跳过当前子类的查找）。
3. 假如爷、父类中存在同名，子类不存在该名，那么想从子类访问到爷类中的成员，就只能通过爷类中的公开方法来到访问调用。



---

## 方法重写/覆盖Override

### 使用

1. 父子类的方法名、参数列表一致
2. 对于方法类型：
   1. 子类方法的方法类型和父类的方法类型一致，
   2. 或者子类方法的类型属于父类方法类型的子类，例如子类方法类型是String，父类方法类型是Object，那么这两种方法类型就形成了父子关系，那么就可以重载。
3. 方法重载时，子类方法的访问权限不可以低于父类方法的访问权限。

### 用途

在父类中同样存在一样的方法，但因为子类需要特有化，因此需要重写。这样保证了，行为的操作都是一样的，只不过内容发生了变化（即方法名、参数列表不变，代码块里的东西改变）。

### Object类

引用名.equals(引用名)，判断引用对象内的值是否相等。

- ```java
  //重写equals()
  public class Employee {
      private String name;
      private int monthSalary;
      public boolean equals(Object obj) {
          if(this == obj) {//引用相等
              return true;
          }
  
          if(obj instanceof Employee) {//继承关系
              Employee e = (Employee)obj;
              return e.name.equals(this.name) && e.monthSalary == this.monthSalary;
          }
  
          return false;
      }
  }
  public class Worker extends Employee{
      public boolean equals(Object obj) {
          if(this == obj) {
              return true;
          }
  
          if(obj instanceof Worker) {
              Worker w = (Worker) obj;
              return super.equals(w);
          }
  
          return false;
      }
  }
  
  ```


引用名.toString(),返回字符串：全类名+@+十六进制哈希值。全类名，即包名+类名。子类需重写，用于返回对象属性信息。当直接输出引用名时，默认调用toString()方法。

- ```java
  //重写
  按alt + ins自动重写
  ```

----

## 多态Polymorphic

### 用处

可以更加通用普遍的调用对象的成员。我们可以通过父类类型引用来接收其本身类型和子类类型的对象，但同时可以通过该引用去访问对象。

### 体现

1. 方法的多态：重写和重载

2. 对象的多态：

   1. 一个对象的编译类型和运行类型可以不一样。如Object obj = new String();，其中Object就称为编译类型，String称为运行类型。
   2. 编译类型在对象定义的时候及已经确定了，不可再改变（因为不可重复定义）。
   3. 运行类型可以改变（因为可以重新给对象进行赋值）。
   4. 编译类型和运行类型的规则：父类的引用可以指向子类的对象，即**<u>编译类型是运行类型的父类</u>**。

   由于需要进行编译，因此，在父类中也需要有和子类一样的成员才可以在运行时调用子类的成员，否则编译不通过，何谈运行。

### 多态的向上转型

#### 本质

父类的引用指向了子类对象

语法

父类类型 引用名 = new 子类类型(参数)；

父类类型 引用名= 引用名；//右式引用名的类型是一个对应子类类型

#### 特点

1. 可以调用父类所有可访问的成员。
2. 不能调用子类的特有成员。因为在编译阶段，能调用哪些成员,是由编译类型来决定的。
3. 编译类型与运行类型不一致

### 多态的向下转型

#### 本质

用于指向子类对象的父类引用赋值给了对应的子类引用

#### 语法

子类类型 引用名 = （子类类型）父类引用名

#### 特点

1. 父类引用指向的对象必须是对应的子类
2. 向下转型后，通过新的引用可以调用子类中所有可访问的成员。
3. 编译类型和运行类型一致



### 抽象理解

向上转型可以看作：就是我声明了一个父类，然后这个父类中仅有new出来的部分被赋值了。因此可以通过新父类引用访问自己本类中的所有可访问的成员。

向下转型可以看作，就是我声明了一个子类，将另一个地方的子类赋值给这个新声明的子类。然后可以通过新子类引用访问本类中所有可访问的成员。

总结就是：表达式右边都是只为了给左式赋值，<u>**实际上左边的引用名可以调用什么成员，还是得看这个引用名的类型，而无关乎右式的类型。**</u>

### 本质理解

#### 编译与运行

实际上，表达式两侧都需要编译成计算器看得懂得文件，但是不做运行计算的操作，也就是说，只是把表达式两侧的语句以及包含的运算符编译（翻译）了一下，实际上进行运算还是等待下一步进行。

那么就可以知道向上转型，最终就是把右式的结果赋值给了左式，那么就相当于右式的类型才是 实际运行后 左式中引用的类型

所有的操作都是先进行编译后运算的。

#### 内存布局

内存大小：实际上，子类所占用的内存大小一般是比父类要大的。因为子类一般会增加很多的特有的成员。

包含关系：当我们新建一个子类对象时，父类的一些成员已经被包含在里面了，因此我们可以用一个父类的引用去指向那些父类成员，进而通过地址访问父类成员。

构造与地址：因为构造都是从Object的构造器开始构造的，因此不管什么类型，地址的空间地址都是没有差别的：引用所指向的都是Object最先占开辟用的地方。

对于方法：由于堆区存放的是成员属性，方法区存放类的信息加载（方法都存放于此），而继承之间的关系都是从子类不断向上查找父类的，故方法的查找一定是从下往上匹配的。（故会出现方法覆盖/重写）

而对于属性：则由对应对象所决定，即子类可以访问堆中对应子类的属性，父类可以访问对应父类中的属性。（没有属性覆盖的说法）



### 多态参数

#### 定义

方法定义的形参类型为父类类型，实参类型可为子类类型

### 关于多态记住一句话

在写代码的时候，为了编译通过，引用能够访问到一定是引用类型下的成员，而不能够是对象（可能是引用类型本身，也有可能是引用类型的子类）。

但是实际上运行的时候，在底层，我们实际上是能够通过引用名访问到对象的成员（不管是引用类型本身还是子类）。而为了达到这种效果，那么可以这么做：

1. 访问成员：当类型一致时，直接访问；当类型不一致时，强制转换类型。
2. 访问方法：当类型一致时，直接加载对应类的方法，可直接访问；当类型不一致时，若两类之间具有方法重写/覆盖，那么直接调用即可（因为加载时子类的方法也加载进去了，因此会从子类的方法开始向上查找）；若两类之间没有重写，那么就需要强转类型。

重点！！！就是！！！内存中究竟加载了什么信息！！！创建了一个子类对象，那么内存中就一定加载了子类的信息，就一定有办法可以访问得到。



----

## 动态绑定机制

调用对象的方法时，会有动态绑定机制。即该方法会和对象的地址产生绑定。

具体表现就是：无论方法中再调用了多少次其他方法，每调用其他方法一次，就**<u>必须回到对象的地址才能开始查找对应的其他方法</u>**。

对于属性来说，没有动态绑定机制。只看当前作用域。

---



## instanof关键字

**`instanceof` 是 Java 的保留关键字，它的作用是测试它左边的对象是否是它右边的类或者子类的实例，返回 `boolean` 的数据类型**

### 用途

1. 使用子类的成员：
   当把子类对象赋给父类引用变量时，这个父类引用变量只能调用父类拥有的方法，不能调用子类特有的方法，即使它实际引用的是子类对象。
   如果需要让这个父类引用变量调用它子类的特有的方法，就必须把它强制转换成子类类型。

2. 筛选可强转时机（例如多态数组遍历）：
   当数组中的元素是符合子类类型时，那么就进入if代码块进行向下转型。

   使得在此代码块中，可以通过引用名调用子类成员。

3. 判断是否可以正确强转（健壮性）：

   把父类实例转换成子类类型，则这个对象必须实际上是子类实例才行，否则将在运行时引发ClassCastException。在强制转换前使用instanceof运算符判断是否可以成功转换。
   

### 注意

- **基本类型完全不能用于 `instanceof `判断**
- null只能放在 `instanceof` 关键字的左边,且无论右边为什么类型，都返回`false`

---

## 断点调试

可以在调式过程中动态的下断点。

可以在一段复杂的逻辑代码中下多个断点，从而可以判断代码是否是进入该代码块还是跳过该代码块去执行其他代码块

----

## 编程思想

### 代码风格

- **<u>写代码块时，逻辑应该越小越好，保证了低耦合</u>**，使得将来可以扩展到其他代码中，或者进行修改功能。
- 在验证数据时，即判断代码执行条件时，**<u>先判断不正确的数据，即先写错误提示的代码块</u>**。

### 对OOP的思考

多态是在继承和封装的基础上拓展出来的。多态就是方法和对象可以具有多种形态的意思。

于继承：

具体来说，对于方法：Override；对于对象：可用父类类型引用接收子类类型对象。

而这些操作都是基于继承的，没有继承那么就不存在Override，以及父子类关系。

于封装：

又因为对象可以由父类类型接收，因此实际上该引用名可以访问到其类型之下的所有子类。具体操作便基于强转。

紧接着就可以通过各对象中封装后给定的方法来访问到内部信息。所以，可以看作多态就是封装的一种出口。



---



## 关于OOP的CRUD

### 实体类

**<u>多运用接口、继承</u>**

- 在**<u>实体类</u>**中重写toString()方法可以通过引用名直接访问属性信息，即业务的基本信息。
- 有访问权限的业务需求时，那么就可以运用封装的思想，**<u>完成实体类的编写</u>**（属性、构造、set、get，具体细节查看**<u>封装的实现步骤</u>**笔记）。
- 当业务的信息多样，但可以抽离出共有属性时，可以运用继承的思想，**<u>完成实体类的编写</u>**（属性、构造、set、get、重写，具体细节查看**<u>继承</u>**笔记）。
- 当业务有继承的需求时，大多数情况下也可以运用上多态的思想，**<u>完成实体类的访问</u>**（向上、向下转型）。

### 其他层级

**<u>多运用多态</u>**

属性一般都是**<u>用于接收实体类中的信息</u>**，或者**<u>辅助功能实现</u>**的一些变量，然后围绕业务信息，辅以辅助变量来实现当前层的功能。

- 对于属性：此处接收实体类型信息，就可以使用多态，通过父类类型的引用来接收。
- 对于方法：形参则可以设置为父类类型，从而可以接收多种类型的实参
- 对于方法中的代码块
  - 可以通过类型判断（instanceof）来获得访问权限（向下转型）；（此处指访问修饰符、类型对应等等java自带的一些访问机制）
  - 同时也可以通过运行类型，设置一些访问权限。（只有指定的类型才可以拥有访问权限，此处指自定义的访问机制）
