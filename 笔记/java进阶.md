# 静态变量

静态变量也称类变量



## 语法

**访问修饰符 static 数据类型 变量名;**

也可以 static 访问修饰符 数据类型 变量名;

## 特点

- 静态变量是同一个类所有对象共享的
- 在类信息加载时就已经生成，随着类的消亡而销毁

jdk8以后静态变量存放于堆区中类对象中，

通过反射机制加载类对象（当类信息在方法区中加载的时候，它会在堆区中生成一个对应的class对象。）

## 用法

**类名.静态变量名;**

也可以对象名.静态变量名;



## 用途

1. 当需要让某个类所有对象共享一个变量时，就可以考虑使用静态变量



# 静态方法

静态方法也称类方法

## 语法、用法

与静态变量相似

## 特点

1. 所有对象共享
2. 在类信息加载时就以生成，位于方法区中，随对象消亡而销毁
3. 不可使用与对象有关的关键字，如this、super
4. 静态方法只能访问静态成员

## 用途

1. 当方法中不涉及任何和对象相关的成员，则可以将方法设计成静态方法，提高开发效率（一般工具类都是static方法）





# main方法解析

1. 被jvm所调用

2. 必须public

3. 必须static

4. 对于String[] args形参是：在执行java命令时，在后面多加的几个实参。

    （如在dos内执行命令：java Hello 实参1 实参2 实参3）

    （在idea中，可以在运行时，edit run/debug configuration 中的 pogram arguments， 即传入动态参数）



# 代码块

代码块也称初始化块

在加载类或者创建对象时，被隐式调用。

## 语法

static{代码}；static可加可不加，分号可加可不加。

## 用途

1. 进行初始化操作，具体表现在：当多个构造器可以抽离出统一的代码时，就可以使用代码块保存起来，从而进行统一的输出（初始化）。（即可以理解为对构造器的补充机制）



## 静态/非静态对比

普通代码块和类加载没有关系，是在创建对象时被调用的，且每创建一次对象就执行一次普通代码块。

静态代码块，**当类加载时就被调用**，且仅最多只能被调用一次静态代码块。

静态代码块中只能调用静态成员。

## 类加载

类加载是在类对象创建之间的操作

1. 当调用静态成员时，类加载
2. 当创建对象时，类加载
3. 当创建子类对象时，父类也会被加载，即父子类都会被加载

## 优先级

类加载-->类信息加载（方法区）（加载方法）--> 类对象加载（堆区）（加载（执行）static变量/代码块。当创建对象后，继续推进-->执行普通变量/代码块-->构造器

## 对于构造器

构造器中第一句默认调用super()，第二句默认调用普通属性/代码块

## 总结

有继承关系时：从父类开始加载；创建对象时，从构造器可知，也是从父类开始进行初始化操作。



# 设计模式

## 认识

设计模式就是在大量的实践中总结和理论化之后**<u>优选的代码结构、编程风格、以及解决问题的思考模式</u>**。





# 单例设计模式

## 认识（用途）

采取一定的办法，保证在整个软件系统中，对于某一个类，只能存在一个对象（只能创建一个实例），且只提供一个可以取得该对象的方法。

javaSE中，java.lang.RunTime就是经典的单例模式。

## 方式

getInstance中Instance写具体的类名

### 饿汉式

#### 步骤

1. 构造器私有化private；（防止用户直接创建对象）
2. 类的内部**<u>创建</u>**私有的静态对象；（staitc修饰才能被getInstance()调用，且保证只提供一个对象）（private保证外部无法直接访问）
3. 向外暴露一个public static方法getInstance()；（public向外提供获取方法）（static修饰才能通过类名直接访问）

可能会出现创建了静态对象却没有使用的情况，造成资源浪费

### 懒汉式

#### 步骤

1. 构造器私有化private；（防止用户直接创建对象）
2. 类的内部**<u>定义</u>**私有的静态对象；（staitc修饰才能被getInstance()调用，且保证只提供一个对象）（private保证外部无法直接访问）
3. 向外暴露一个public static方法getInstance()；（public向外提供获取方法）（static修饰才能通过类名直接访问）
4. 在getInstance()方法中，判断静态对象是否指向null，如果true，则创建对象；否则直接返回已创建过的对象。



## 对比两种方式

1. 二者区别在于创建对象的时机不同，饿汉式在类对象加载时创建对象；懒汉式在类方法被首次调用时创建对象。
2. 饿汉式不存在线程安全问题，而懒汉式存在（多线程操作时，存在某个时机可以创建多个对象）。
3. 饿汉式存在浪费资源的问题，而懒汉式不存在。



# final关键字

final可以修饰类、类成员和局部变量，不可修饰代码块

## 语法

访问修饰符 final ......

## 用途

1. 对于类：不想该类被继承时，可以用final修饰。
2. 对于方法：不想该方法被子类重写时，可以用final修饰。
3. 对于类的属性、局部变量：不想该属性的值被修改，可以用final修饰。

## 细节

1. 被final修饰的属性称为**常量**，此时变量名全部大写字母，且单词之间用下划线隔开。

2. 被final修饰的属性**必须赋初始值**。

    1. 对于非静态：赋值位置可以在声明中、代码块中以及构造器中。
    2. 对于静态：位置在声明中、静态代码块中，不可以在构造器中初始化。

3. 被final修饰的方法只是不能被重写，但是可以被继承。
4. 被final修饰的类中，就没有必要再用final修饰方法了。因为该类不可能被继承，那么也就不可能被重写。
5. 方法中的形参列表中形参可以被final修饰。相当于声明一个被final修饰局部变量。
6. 对于类成员，**final和static往往搭配使用**，效率更高。因为这将不会导致类加载（底层编译器做好的优化）。
7. 包装类（Intege、Double、Boolen...）都是final类，String也是final类。



# 抽象类（abstract关键字）

abstract可以修饰类和方法，其他都不可以

### 语法

访问修饰符 abstract ...

### 用法

当父类的一些方法不确定时，可以用abstract声明该方法。

1. 对于父类：先用abstract修饰父类（这个类就称抽象类）。
2. 对于方法：用abstract修饰方法（这个方法就称抽象方法）。
3. 对于子类：具体重写（实现）这个抽象方法。

### 用途

1. 其实这些方法就是抽离出来的一些共有的、抽象的行为，但是这个行为内部又可以拥有很多的细节（具体子类具体实现）。
2. 在框架和设计模式中用得较多。

### 细节

1. 抽象类无法实例化。
2. 抽象类**不一定**要包含abstract方法。
3. 一旦类中包含了abstract方法，那么这个类也**必须**被abstract修饰。
4. 被abstract修饰的方法不能有方法体（只是声明一个抽象方法）。
5. 如果一个类继承了抽象类，那么这个子类**必须重写**（实现）抽象类中得抽象方法，除非该子类也声明为一个抽象类。
6. 抽象方法都不可以被private、final、static修饰。因为这与重写的语法相违背。



# 模板设计模式

抽象类、多态、继承、动态绑定机制的实践运用

抽象类的运用：抽离出一些共有行为和抽象行为，让子类来具体实现。

动态绑定机制的运用：实例化的只能是子类，但调用的方法实际上可能是父类的一个方法，该方法中调用了抽象方法，再次查找方法时是从运行类型开始查找的。

多态的运用：在调用时可以用父类类型接收子类类型。





# 接口

## 认识

给出一些没有实现，只有声明的方法，将其封装到一个接口中。当某个类需要使用的这个接口的时候，在根据具体情况重写实现这些方法。

## 语法

创建接口 ：interface 接口名{属性、方法}使用接口：class 类名 implements 接口名 {属性、方法、重写方法}

## 版本问题

jdk8以前，接口内只能是声明方法，不得实现。

jdk8以后，接口内**可以有具体实现的方法**：静态（static修饰符）方法、默认（default修饰符）方法，

#### 接口为什么新增了默认方法和静态方法？

我们的接口老早就写好了，后面因为各种业务问题，避免不了要修改接口。

在Java 8之前，比如要在一个接口中添加一个抽象方法，那所有的接口实现类都要去实现这个方法，不然就会编译错误，而某些实现类根本就不需要实现这个方法也被迫要写一个空实现，改动会非常大。

所以，接口默认方法就是为了解决这个问题，只要在一个接口添加了一个默认方法，所有的实现类就自动继承，不需要改动任何实现类，也不会影响业务。

- 另外，接口默认方法**可以**被接口实现类重写。
- 接口静态方法和默认方法类似，只是接口静态方法**不可以**被接口实现类重写

接口静态方法**只可以**直接通过静态方法所在的接口名.静态方法名来调用。

## 细节

1. 接口不可以实例化

2. 接口中的抽象方法可以不加修饰符直接声明，默认是public abstract。

3. 接口中具体实现的方法必须加访问修饰符（一般是加default）。

4. 属性可以不加修饰符进行定义，必须得赋值，默认是public static final。

5. 抽象类实现（implements）接口，**可以不用**重写接口的抽象方法。

6. 普通类实现（implements）接口，**必须重写**实现接口的抽象方法。

7. 一个类可以**同时实现多个接口**

    语法：class 类名 implements 接口名1,接口名2,......{}

8. 接口不能继承其他类，但是可以**继承接口**。

9. 接口是存在**多继承**的。

    语法：interface 接口名 extends 接口名1,接口名2,......{}

10. 接口的访问修饰符只能是public和默认，和类一样。

## 用途

接口实际上就是封装存放一些公共的、统一的方法。



### VS继承

#### 对java单继承机制的补充

语法：子类名 extends 父类名 implements 接口1,接口2,......

即实现了子类可以超出父类的范围，去拥有其他的行为。

1. 也可以理解为接口内的方法可能是不能被抽离放在父类中的
2. 也可以理解为子类中的方法，可以抽离成好几种类型，分为父类、接口1、接口2、......

#### 价值用法对比

- 继承：解决代码复用性和维护性，更加偏向于实际对象的抽象化

- 接口：声明设计规范（或者行为方法），让其他类来具体实现，更加偏向于对象行为的抽象化

由于接口只需要考虑行为动作，因此接口更加的灵活。

接口在一定程度上也可以实现代码解耦（即通过接口规范性 + 动态绑定机制 ）



## VS多态

接口引用可以指向实现了该类的对象。

如存在一个接口IA，一个类BB实现了IA，那么就有IA ia = new BB();

对于方法中的形参也一样，形参参数为(接口名 变量名)，那么可以入实现了该接口的对象。

对于多态数组也差不多，可以具体看看多态的笔记。

# 内部类

一个类中又完整的嵌套了另一个类，被嵌套的类称为内部类（inner class）；嵌套其他类的类统称为外部类（outer class）。

**<u>内部类可以访问外部类所有成员（静态内部类特殊处理）。</u>**

## 分类

定义在外部类的局部位置上（方法或者代码块中）

1. 局部内部类（有类名）
2. 匿名内部类（无类名）

定义在外部类的成员位置上

1. 成员内部类（无static）
2. 静态内部类（有static）

## 局部内部类

### 细节

1. **优先级/地位属于“局部”**
2. 局部内部类是定义在外部类的局部位置，**通常在方法中**
3. 因为是“局部”所以不能被访问修饰符修饰，但可以用final（不想被其他的内部类继承）
4. 作用域：只在定义它的方法或者代码块中具有作用
5. 如果内部类和外部类的成员重名时，默认遵循就近原则。当想访问外部类的成员时，可以通过：**外部类名.this.成员名** 去访问。（此时this指向的时内部类的对象实例，外部类名.this实际上指向的就是外部类的对象实例）

### 访问关系

- 内部类访问外部类，直接访问，重名时访问外部类，**外部类名.this.成员名** 。
- 外部类访问内部类，创建对象后再访问。
- 外部其他类不能访问内部类，因为属于“局部”。

## 匿名(Anonymous)内部类

### 语法

new 类/接口(参数列表){ 代码 };

### 用法

可隐含多态、继承的用法。（向上转型）（继承方法）（花括号中一般不加构造器）（参数列表一般不填）

接口 变量名 = new 接口() {代码};

类 引用名 = new 类() {代码};

### 底层

实际上，在执行new的时候，底层会做一个操作

1. 创建一个类，该类**继承/实现了一个父类/接口**。（此时底层是会分配一个名字当作类名的，也是就是类型）
2. 其中参数列表会传给构造器
3. 然后再执行花括号{}中的代码
4. 最后返回该对象的地址，令引用名/变量名指向该对象。

此时再回来看上面的用法，可知**一定是一种向上转型**。

此时再讨论编译类型和运行类型，就可以知道，**编译类型是左边的，而运行类型则是由底层分配好的**。因此调用方法时，也遵循了动态绑定机制。

### 用途

对于某个对象，我只需要调用一次。为了防止多创建一个类浪费资源，因此使用匿名内部类。

实际上就是，开发过程中，匿名内部类作为一个参数传入方法中，该方法调用了形参的方法。

如：方法名（new 类/接口(){}）;

具体看下面的总结

### 细节

几乎和局部内部类的细节差不多，但是对于第3点，因为用法的原因，所以没有必要关注修饰符。

### 访问关系

- 内部类访问外部类，直接访问，重名时访问外部类，**外部类名.this.成员名** 。
- 外部类访问内部类，创建对象后再访问。（因为用途的关系，所以基本不存在）
- 外部其他类不能访问内部类，因为属于“局部”。

## 成员内部类

### 细节

1. **优先级属于“类成员”**
2. 无static修饰
3. 可以加任意访问修饰符（public、protected、默认、private）
4. 作用域：属于成员，在类中都存在作用范围

### 访问关系

- 内部类访问外部类，直接访问，重名时访问外部类，**外部类名.this.成员名** 。
- 外部类访问内部类，创建对象后再访问。
- 外部其他类访问内部类：（若只想创建内部类的对象，那么以下的第一步都可以不用引用接收，而是直接匿名创建外部类对象）
    1. 创建外部类对象后，再创建内部类对象。
    2. 创建外部类对象后，再调用外部类中能够**获取内部类对象的方法**

## 静态内部类

### 细节

与成员内部类几乎一致，但对于第2点，静态内部类由static修饰。

**静态内部类不持有指向外部类对象的引用this**

### 访问关系

- 内部类访问外部类，直接访问（仅限静态成员），重名时访问外部类，**外部类名.成员名** 。
- 外部类访问内部类，创建对象后再访问。
- 外部其他类访问内部类：（若只想创建内部类的对象，那么以下的第一步都可以不用引用接收，而是直接匿名创建外部类对象）
    1. 创建外部类对象后，再创建内部类对象。
    2. 创建外部类对象后，再调用外部类中能够**获取内部类对象的<u>静态</u>方法**



## 总结

#### 内部类

作用

1. 每个内部类都能独立的完成一个接口的实现，所以无论外部类是否已经完成了某个（接口）实现，对于内部类都没有影响。内部类使得**多重继承**的解决方案变得完整。
2. 方便将存在一定逻辑关系的类组织在一起，又可以**对外界隐藏**。
3. 方便编写事件驱动程序。
4. 方便编写线程代码。

认识

- 内部类与所在外部类有一定的关系，往往只有该外部类调用此内部类，所以没有必要专门用一个Java文件存放这个类。
- 内部类体现了一种代码的隐藏机制和访问控制机制。

#### 成员内部类使用场景

1. 不可能有其他类使用该内部类。 
2. 该内部类不能被其他类使用，可能会导致错误。

#### 匿名内部类使用场景

1. 在**编写事件监听的代码**时匿名内部类不但**方便**，而且使代码更加**容易维护**。
2. 匿名内部类的使用范围非常有限，大部分匿名内部类用于**接口回调**。

#### 静态内部类

丧失了多继承的效果。大概只在特定情况会用到。

# 总结关键字常用位置

| 关键字       | 运用位置                                       |
| ------------ | ---------------------------------------------- |
| static       | 成员属性、成员方法、~~接口中的具体的实现方法~~ |
| final        | 类、~~成员属性~~、成员方法、局部变量           |
| abstract     | 类、成员方法                                   |
| default      | 接口中的具体实现方法                           |
| static+final | 成员属性                                       |
| private      | 封装成员属性、~~封装成员方法~~                 |
|              |                                                |
|              |                                                |
|              |                                                |
