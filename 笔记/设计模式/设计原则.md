# 继承的优缺点

## 优点

1. 代码复用性高，子类可以拥有父类的属性、方法
2. 代码可扩展，子类可以扩展自己的特色属性、方法

## 缺点

1. 代码具有侵入性，子类必须拥有父类所有的属性和方法
2. 耦合度高，修改父类代码，可能子类同时遭受波动

# 开闭原则

使用：

1. 对扩展开放，对修改关闭。
2. 分离出抽象层，扩展在具体子类上进行，而无需改动抽象层



# 里氏替换原则

因为继承的具有侵入性、高耦合的缺点，因此需要遵守LSP。

使用：

1. 子类必须实现父类的抽象方法，但不得重写（覆盖）父类的非抽象（已实现）方法。
2. 子类中可以增加自己特有的方法。
3. 当子类覆盖或实现父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。
4. 当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。

使用详解看[这里](https://www.cnblogs.com/o-andy-o/p/10315188.html)

遵守了LSP，那么就一定可以用抽象类/接口来接收具体子类。

# 依赖倒置原则

使用：

1. 完成业务时，尽量先得到抽象层（抽象类/接口）；
1. 然后配合LSP 使得声明时，可尽量使用抽象类/接口来接收具体子类。

## 图解

![](https://img-blog.csdnimg.cn/20201118123358462.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDgyOTkzMA==,size_16,color_FFFFFF,t_70#pic_center)

1. 调用者不应该直接依赖具体实现类,两者都应该依赖对应的抽象。
2. 就是所有具有依赖关系的类，它们一定是具体类依赖于接口(具体依赖于抽象)。
3. 面向对象编程的最终归宿一定是抽象。从具体业务走向抽象功能。

- 依赖倒置的本质是**通过抽象（接口或抽象类）使各个类或模块的实现彼此独立，互不影响，实现模块间的松耦合。**

> 抽象的改动对具体子类的影响是相对较小的。接口相对于抽象类更好，因为改动后的影响可以更加小。



## 总结

1. 任何类型都不应该从具体类派生，即应该从抽象类或接口派生。即继承关系尽量在两层或者三层（前两层都是抽象、后一层才是具体子类）

2. 依赖倒置原则**中心思想是面向接口编程**。即用抽象类型接收具体对象（对于属性）、作为方法形参和方法返回类型（对于方法）。

    DIP（中心思想面向接口编程）令代码仅仅是依赖于抽象层，而不依赖于具体业务，因此实现低耦合。

    低耦合因为抽象层统一了可调用的成员（该成员一定是具体子类也拥有的，从而降低了耦合度（即不会出现过于依赖具体子类某种特有成员（重写后也相当于特有）的情况））。

    - 如果不符合LSP中不重写父类方法的准则，那么就有可能造成，调用缺省方法时，调用的不是统一的缺省方法

# 单一职责原则

使用：

1. 一个类只能被一个因素影响。
2. 类中可以同时存在多种功能行为
3. 综上两条就是：
    1. 如果一个类被一个因素影响后，类中所有功能同时被影响是可行的；
    2. 如果一个类被一个因素影响后，类中功能并不是被同时影响，而有时间偏差的话——例如一个功能实际上被另一个功能所影响，而不是“因素”所影响——那么就不符合单一职责原则。



# 迪米特原则

使用：

1. 降低类成员的访问权限
2. 降低类中再对其他类的引用
3. 减少对类的修改

避免引用、减少访问



# 接口分离原则

将不同的功能分散到不同接口，即定义专门的接口来声明功能。保证客户端实现的接口是必要依赖的，而不需要实现不必要的功能。进而实现低耦合。



# 合成复用原则

复用时要尽量使用组合/聚合关系（关联关系），少用继承





# 特性

1. 可维护性可以简单的分为两个层面，一是对过去，二是对未来。
    1. 过去是指，你已经编写好的代码。
    2. 未来是指，你可以继续编写的代码。
2. 故对于可维护性来说，
    1. 首先得有**可读性**，所以要做到变量命名规范，写注释等。
        1. 有时候可能需要将方法的返回值额外用变量来接收，这样可读性增加了(有变量的命名)，同时可调试性也增加了(debug时可以看到具体返回了什么)。
        2. 同时不应该将不同功能的算法耦合在一起，其实也就是说功能划分，将一种功能算法抽离放到一个方法里头，在需要时调用即可，这也恰好实现了可扩展性和复用性。
    2. 同时也应该利于调试，故需要**可调试性**。
        1. 对于异常，我认为可能将受查异常额外处理之后再抛出去会更好调试，例如在抛异常前打印日志，或者用更加精确自定义异常来向外，同时也可以在抛出自定义异常前将原来的异常设置为cause。
    3. 要实现**高内聚低耦合**，这不仅对于一个类来说要遵循这个原则，对于一个方法也可以。
        1. 一个方法向外暴露的东西就是他的形参列表，故列表中的参数越少，其实就代表他越符合高内聚(功能的实现集成在方法体内，而与外界无关)，也符合低耦合(外界传入的参数越少，说明联系越少)。
    4. 然后是需要**可扩展性**，维护不仅是对已有的代码进行维护，可能还要在原来的基础上进行扩展。
        1. 主要是尽量不要变动原有代码的同时做到引入新功能。
        2. 对于扩展性来说，其实它的限制在于原先已实现的代码。原先的代码是否提供了扩展的空间很重要。
