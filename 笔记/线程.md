# 线程

## 认识

程序：完成任务，用某语言编写的一组指令集合。

进程：运行中的程序。是一个动态过程：有产生、存在和消亡的过程。

线程：由进程创建，是进程的一个实体。

一个进程可拥有多个线程。



单线程：同一时刻，只允许执行一个线程。

多线程：同一时刻，可以执行多个线程。

并发：同一时刻，多个任务交替执行。如单核cpu。

并行：同一时刻，多个任务同时执行，如多核cpu。



## 使用

1. 继承Thread类，重写run方法，调用Thread类的start()方法
2. 实现Runnable接口，重写run方法，调用Thread类的start()方法

底层都是调用`start0()`方法，该方法由jvm调用。

调用start0()方法后也不是立马执行，而是变为可运行状态，具体执行的时间，根据操作系，由cpu统一调度。

具体使用：

~~~java
//Thread
class A extends Thread {
    @Override
    public void run() {
        //代码...
    }
}
class M {
    public static void main() {
        A a = new A();
        a.start();//该start方法是Thread类中的方法
        //a.start();//不能再次在同一对象的线程执行过程中，再创建一个线程。
        A aa = new A();
        aa.start();//可以再创建一个对象，去执行另一个线程
    }
}

//Runnable
class A implements Runnable{
    @Override
    public void run() {
        //代码...
    }
}
class M {
    public static void main() {
        A a = new A();
        Thread t1 = new Thread(a);
        Thread t2 = new Thread(a);
        //t1和t2是两个不同的对象，可以创建两个线程，同时调用的又都是a的run方法，即实时共享数据。
        t1.start();
        t2.start();
    }
}
~~~

## Thread与Runnable区别

本质上是没有区别的，但是用法有区别。

- 实现Runnable接口更加适合多线程共享一个资源的情况。且可以避免单继承的限制。

- 继承Thread类想实现多线程共享一个资源的话，就需要配合static达到共享的目的。

Runnable创建线程，实际上用到了静态代理模式。即实际上是将创建线程的任务，通过Thread类中的start()方法去调用start0()方法完成的。



## 线程常用方法

| 方法（普通）      | 作用                                                    |
| ----------------- | ------------------------------------------------------- |
| setName(String)   | 设置线程名字                                            |
| getName()         | 获取线程名字                                            |
|                   |                                                         |
| run()             | 调用重写的run()方法                                     |
| start()           | 调用线程                                                |
|                   |                                                         |
| setPriority(int)  | 设置优先级                                              |
| getPriority()     | 获取优先级                                              |
|                   |                                                         |
| sleep(long)//静态 | 休眠                                                    |
| interrupt()       | 中断休眠                                                |
|                   |                                                         |
| yield()//静态     | 线程让出cpu。不一定成功，由cpu紧张程度决定              |
| join()            | 线程插入，抢占cpu。直到该线程执行完才能去执行其他线程。 |



## 工作线程与守护线程

工作线程也称用户线程。当任务执行完或者以通知方式来结束。

守护线程：

1. 一般为工作线程服务，当所有的工作线程结束时，守护线程自动结束。
2. 一般用于监控其他线程，方便管理多线程。
3. 常见的守护线程就是垃圾回收机制。

使用方式：在线程启动前设置为守护线程。

~~~java
t1.setDaemon(true);
t1.start();
~~~

## 线程状态

![](https://img-blog.csdnimg.cn/d9adb825ead94cb9a83861da8745b361.png)



## Synchronized关键字

线程同步：当一个线程在对内存操作时，其他线程都不能在这个内存进行操作，而是进入BLOCKED状态，直到第一个线程完成操作。

使用方法：

~~~java
//1. 同步代码块
synchronized (对象) {}

//2. 同步方法
public synchronized void methon() {}
~~~

## 互斥锁

1. 每个对象都有一个对应的互斥锁标记
2. synchronized关键字来与对象的互斥锁联系。当对象被synchronized修饰后，即上锁
3. 局限是会降低效率。
4. 同步时，若也被static修饰，则联系的对象是对应类的class对象，即类名.class。
5. 同步时，若不被static修饰，则联系的对象默认是实例化的对象，即this。

### 使用的重点

在多线程时，保证上锁的代码关联的是同一个对象。

因此实现Runnable接口，并用带参构造线程来创建多线程（参数为同一对象）就可以保证多线程操作的是同一个对象。

而用继承Thread类，来创建多线程，一般是不会联系到同一对象的。除非在用static来保证共享资源的同时，其中上锁的对象也是static的，这样就可以保证每次联系的是同一对象。



### 推荐使用

同步代码块（作用范围小，维护方便）+Runnable接口（可共享资源）



## 释放锁

1. 线程中的同步方法、同步代码块执行完毕时

2. 提前退出同步方法、同步代码块

    1. 出现了未处理的异常
    2. 可能的break和return

3. 在同步方法、同步代码块中执行了线程对象的wait()方法，使当前线程暂停，并释放锁。

注意：

1. Thread.sleep()和Thread.yield()不会暂停线程执行，不会释放锁。



