# java注意的地方

## 变量

char内存大小为2个字节，可以存放汉字

short、byte、char之间不会自动转换。

short、byte、char在进行计算的时候，先转化为int类型计算。

其他基本数据类型之间的计算时，先转换为表达式中数据精度最大的来计算。

String可以运用在switch中来当作判断

## 编码

asc||只有128个字符，一个字符用1个字节保存。

unicode是万国码，任意一个字符都用2个字节进行保存。拥有局限，即浪费空间或者空间不足的情况。

utf-8是unicode的优化版。是一种动态的编码，一个字符可以利用一到六个字节来进行保存。英文字母为1字节，汉字为3字节

## 类和对象内存分配

![](/C:/Users/silent_child/AppData/Roaming/Typora/typora-user-images/image-20230107140103135.png)

----





## 方法调用细节（规则）

![img](https://img-blog.csdnimg.cn/9ea74ed5a5d2454688ebbdc7975a4216.png)

----



## 可变参数

可变参数本质是数组？数组不是引用类型吗？引用的值不是都放在堆区吗？

但是传入的实参不是数组时，实际上是值（值常量）传进来，而不是地址传进来。实参传入的是数组时，传进来的才是地址（指向堆区的地址）。

似乎可以这么理解：可变参数实质就是数组，而当我们传入的是多个同类型的实参变量时：首先，假设可变参数是int... num,当执行该方法时，在栈区开辟空间，然后在这个空间内声明一个变量num（即数组名），该空间保存的是指向堆区的一个地址，在堆区的这个地方，开辟了传入参数对应大小的空间，并将传入参数的值赋给这些空间保存下来。

普通的可变参数(int... num)可以传入数组或者多种同类型数据，传入的是一个指向堆区的地址。

普通的可变参数（int... num），可以用数组的形式来访问数据。

即普通的可变参数可以当作一维数组来处理。

可通过这样：int[]... num来传入二维数组。

---



## 修饰符（public、private、默认、protected）与变量

全局变量可使用修饰符，局部变量不可使用修饰符。



----



## 构造器

![image-20230107174941346](C:\Users\silent_child\AppData\Roaming\Typora\typora-user-images\image-20230107174941346.png)

----



## this细节

![image-20230107181750576](C:\Users\silent_child\AppData\Roaming\Typora\typora-user-images\image-20230107181750576.png)



----





## 包的使用

### 注意

不同包之间的类只有public的才能导入使用，且只有类中public的成员才可以访问。

### 可在不同包下创建相同类名

在调用多种相同类名的时候，可以先导包，也可以直接输入完整的包名加类名（输入路径的标准/参考是啥？）。

如：

![image-20230107221635060](C:\Users\silent_child\AppData\Roaming\Typora\typora-user-images\image-20230107221635060.png)

### 命名

1. 通常只使用小写字母
   
1. 通常每个包的名字只使用1个单词
   
1. 域名倒置
    通常使用组织的网络域名的逆序,例如:
    如果域名为javagroup.com,包可以命名为:com.javagroup.mypackage
    目前我们能使用的包名前缀只有 "com" 和 "cn"           
    
1. 包名的后续部分依不同机构各自内部的规范不同而不同.这类命名规范可能以特定
    目录名的组成来区分部门、项目、机器或注册名
    例:com.javagroup.research.powerproject
               项目名        部门名
    
1. . 父包和子包之间使用"."分隔          
   
    

![image-20230107221524270](C:\Users\silent_child\AppData\Roaming\Typora\typora-user-images\image-20230107221524270.png)

### 常用的自定义包名

1. dao: 数据处理包。
   1. 数据库相关操作 数据访问。
   2. 数据访问层：就是用来访问数据库实现数据的持久化（把内存中的数据永久保存到硬盘中 ）。
2. domain（entity）: 实体类包
3. service: 业务处理包. 
   1. 在此层做相应的业务逻辑处理。
4. util: 工具包. utility应用程序
5. test: 测试包. 
6. web：一般 存放 servlet 和 filter 。
7. impl：
   1. impl是implement的简写，换言之，放置的应该是接口的实现类。
   2. 一般三层开发中，service层和dao层都会有接口及其实现类，为了项目能更好的管理和开发，一般将接口放一个包，实现类放置在这个包的子包中。

### 导包

![image-20230107221546085](C:\Users\silent_child\AppData\Roaming\Typora\typora-user-images\image-20230107221546085.png)

java.util.Arrays

- arrays.sort(),排序数组。
- arrays.binarySearch(),二分查找。

java.lang（默认包）

- 基础数据类型的对象.parse基础数据类型(字符串类型引用),返回引用中对应数值的基础数据类型数值，如：

```java
String b = "8";
int s = Integer.parseInt(b);//s == 8;
```

Java.lang.Object(默认)

- 引用名.equals(引用名)，判断引用对象内的值是否相等。

  - ```java
    //重写equals()
    public class Employee {
        private String name;
        private int monthSalary;
        public boolean equals(Object obj) {
            if(this == obj) {
                return true;
            }
    
            if(obj instanceof Employee) {
                Employee e = (Employee)obj;
                return e.name.equals(this.name) && e.monthSalary == this.monthSalary;
            }
    
            return false;
        }
    }
    public class Worker extends Employee{
        public boolean equals(Object obj) {
            if(this == obj) {
                return true;
            }
    
            if(obj instanceof Worker) {
                Worker w = (Worker) obj;
                return super.equals(w);
            }
    
            return false;
        }
    }
    ```

    

- 引用名.hashcode(),用于返回对象的哈希值，哈希值与地址挂钩.在集合中如果需要的话也得重写。

- 引用名.toString(),返回字符串：全类名+@+十六进制哈希值。全类名，即包名+类名。子类需重写，用于返回对象属性信息。当直接输出引用名时，默认调用toString()方法。

  - ```java
    //重写
    按alt + ins自动重写
    ```

- 引用名.getClass(),返回运行类型，（返回字符串：class 全类名）

java.util.Scanner

- 导入Scanner类





![image-20230107221025595](C:\Users\silent_child\AppData\Roaming\Typora\typora-user-images\image-20230107221025595.png)

### 细节

![image-20230107221556508](C:\Users\silent_child\AppData\Roaming\Typora\typora-user-images\image-20230107221556508.png)





----



## 访问修饰符（以访问权限最多为准）

~~public谁都可以访问，private谁都不可以访问~~

### 运用方式

public：它往往用于对外的情况，也就是对象或类对外的一种接口的形式。

protected：它的含义在于子类可以用它修饰的成员，其他的不可以，它相当于传递给子类的一种继承的东西。

default：它是针对本包访问而设计的，任何处于本包下的类、接口、异常等，都可以相互访问。

private：大多数的成员变量都是修饰符为private的，它们不希望被其他任何外部的类访问。（封装的体现）

### 表格

| 访问级别        | 访问修饰符 | 同类 | 同包 | 子类 | 不同包 |
| --------------- | ---------- | :--: | :--: | :--: | :----: |
| 公开            | public     | √    |   √   | √    | √     |
| 受保护          | protected  |    √  | √    |   √   |  ×      |
| 默认（default） | 无         |   √   | √    |   ×   | × |
| 私有            | private    |   √   | × |   ×   | × |

1. 修饰符可以用来修饰成员变量、成员方法、类
2. 只有默认和public可以修饰类（每一个.java文件中最多只能存在一个public的类，且该public类是该.java的文件名）。
3. 对于protected同包中可以看做是public，异包中可以看做private。（尽管是异包，但若是继承关系，那么protected也看做public。也就是从不同包转为了子类的关系，那么就可以拥有访问权了）
4. 实际上可以这么理解：**<u>访问权限是以最多的为准</u>**。例如：
   1. 不同包之间也可以为继承关系（子类），此时访问权限只有public和protected的成员；
   2. 但如果是同包之间的继承关系，那么此时就有public、protected和默认的访问权限。


### 注意

一个java文件可以存在多个类，那么实际上这些类就都可以算作是在同一包下。

**<u>同一java文件下/同一个包下</u>**的所有类之间肯定可以互相调用。

子类对于访问修饰符重点在于父子关系，否则视为正常的一个类来看待修饰符即可。（在作为<u>**子类且同包**</u>的情况下，我们只需要关注父类中那些被private修饰的属性/方法）。

**Java的[访问控制](https://so.csdn.net/so/search?q=访问控制&spm=1001.2101.3001.7020)是停留在**编译层的**，也就是它**不会在.class文件中留下任何的痕迹，只在编译的时候进行访问控制的检查。其实，通过反射的手段，是可以访问任何包下任何类中的成员，例如，访问类的私有成员也是可能的。

### 总结

故当我们考虑访问权限的时候，我们只需要注意三件事情：

1. 是否都是在当前类（先不考虑子类）下调用；同类下操作无论被什么修饰都可以访问（不考虑static之类的）。
2. 是否在当前包下调用（导入后调用）；在包之间操作时，注意类是否是public。
3. 当前类是否为子类；继承一般都在同一包下操作，故重点关注类中的成员访问权限，即成员是否是privat。



----



## 封装Encapsulation

### 好处

1. 隐藏实现细节
2. 可以对数据进行验证，保证数据安全合理

封装讲明白点其实就是将客观事物抽象出来为一个模板，将抽象出来的数据和行为封装到一个类里面，数据被保护在了内部（安全性），不允许外部程序直接变更数据，只允许通过给定的方法对内部信息进行访问和操作。
相当于机箱而言，他里面的硬件的代码是厂商是自己写好了，硬件间的联系也是通过给定接口进行互通的。计算机也需要一个机箱把各种配件封装进去，如主板、CPU、内存、显卡、硬盘等。一方面，机箱起到保护作用，防止异物（如昆虫）进入内部而破坏电路；另一方面，机箱也不是完全封闭的，它一定对外预留有一些访问接口，如开机按钮、USB接口等，这样用户才能够使用计算机

封装好的类对于我们而言可以看成黑箱，我们不知道他内部具体的实现细节和运转机制，我们只能访问暴露出来的属性和方法。但是封装过度也是存在着问题的 如果把不相干的对象，属性封装在一起，会变得更加难以维护

一个类应该是属性和方法合理有效地封装在一块

封装确实是为了高内聚低耦合

### 实现步骤

1. 将属性进行私有化（private只有允许在当前类下访问，故外界要访问到该属性，**<u>必须</u>**通过其他方式，即可访问的方法（一般来说是public修饰的方法）来对其这些属性进行操作）

2. 提供一个公共的set()方法，用于对属性进行判断并赋值

   ```java
   public void setXxx(类型 参数名， ...) {//Xxx表示某个属性
   	//设置验证数据的业务逻辑
       //设置验证访问权限的业务逻辑
       
       //符合则：成员属性 = 参数
   }
   ```

   <u>**可将set()方法写入构造器中，从而达到封装的效果（访问权限受限、数据验证）**</u>

   构造器一般选择构造所有属性。

3. 提供一个公共的get()方法，用于获取属性的值

   ```java
   public 方法类型 getXxx() {//Xxx表示某个属性
   	//设置验证访问权限的业务逻辑
       
      
       return xx；//符合则返回
   }
   ```

-----



## 继承Extends

### 用途

子类是在父类的基础上创建的，可以拥有父类的成员。这样保证了各个对象的层级可以从大到小不断细分。

### 好处

1. 提高代码复用性，减少代码冗杂
2. 提高代码扩展性和维护性。

### 基本语法

```java
class 子类名 extends 父类名{
		
}
```

### 特点

1. 子类会自动拥有父类的所有属性和所有方法
2. 父类又叫做超类、基类
3. 子类又叫做派生类

### 使用方法

父类写共有属性/方法。

子类写特有属性/方法。

### 继承需要关注的细节

1. 父类的**<u>私有属性/方法</u>**不能在子类中进行直接访问，但可以通过一些公有方法进行间接访问。
2. 关于构造器：
   1. 在创建子类对象，并调用子类的构造器（不管哪种构造器）时，同时也会调用父类的构造器。
   2. 对于父类的构造器：
      1. 默认无参构造器（因为子类的构造器中默认存在super();而这句话会调用父类的无参构造器）
      2. 如果没有无参构造器，那么必须在子类中利用super()指定父类的构造器来为父类的属性进行初始化。
   3. 子类需要指定父类的初始化方法时，可以在子类构造器中利用super(参数);来调用指定的父类构造器.
   4. super(参数)和this(参数)都只能放在构造器的第一行，且至多存在一个，即不能同时出现super()和this().
   5. super()只能在构造器中使用.

3. 所有的类都是Object的子类.
4. java是单继承机制，子类最多只能继承一个父类。
5. 在同一包下，所创建的类**<u>除了私有都可以进行继承</u>**。在继承中，私有成员无法被继承，子类无法使用父类的私有成员。
6. 继承一般都在同一包下操作，故重点关注类中的成员访问权限，即成员是否是privat。

### 继承的内存分布

#### 图表

![image-20230108011649501](C:\Users\silent_child\AppData\Roaming\Typora\typora-user-images\image-20230108011649501.png)

如果Father里的age是private，即使GrandPa里也有age，是public，访问age的时候一样到Father就会停止，不会继续查看GrandPa里是否有age。

##### 按照查找关系来返回信息：

对于属性：

1. 首先看子类是否有该属性 
2. 如果子类有这个属性，并且可以访问，则返回信息 
3. 如果子类没有这个属性，就看父类有没有这个属性(如果父类有该属性，并且可以访问，就返回信息..) 
4. 如果父类没有就按照(3)的规则，继续找上级父类，直到 Object...

对于方法：

1. 首先看子类是否有该方法
2. 如果子类有这个方法，且可以调用，则调用
3. 如果子类没有这个方法，就看父类有没有这个方法（如果父类有这个方法，且可以调用（当被private修饰时不可调用），则调用）
4. 如果父类没有这个方法，那么就按照（3）的规则，继续找上级父类，直到Object...

----



## super

### 基本语法

与this基本一致，用于访问父类的属性/方法和构造器。

当属性和方法为私有时无法访问；构造器的用法与this一致，细节已在继承部分提到。

### 按照查找关系来返回信息：

对于属性：

1. 首先看子类是否有该属性 
2. 如果子类有这个属性，并且可以访问，则返回信息 
3. 如果子类没有这个属性，就看父类有没有这个属性(如果父类有该属性，并且可以访问，就返回信息..) 
4. 如果父类没有就按照(3)的规则，继续找上级父类，直到 Object...

对于方法：

1. 首先看子类是否有该方法
2. 如果子类有这个方法，且可以调用，则调用
3. 如果子类没有这个方法，就看父类有没有这个方法（如果父类有这个方法，且可以调用（当被private修饰时不可调用），则调用）
4. 如果父类没有这个方法，那么就按照（3）的规则，继续找上级父类，直到Object...

### 好处

1. 对于构造器：分工明确，由各自类的构造器来进行属性的初始化（即子类属性由子类的构造器初始化，父类属性由父类构造器初始化）。
2. 可访问父类的成员/方法。

### 细节

1. 当父子类中的成员（属性/方法）有重名时，为了访问父类的成员，必须通过super。
2. 如果父子类中的成员不重名，则用this和成员名直接访问是一样的；而对于super则是直接从父类开始查找访问（即跳过当前子类的查找）。
3. 假如爷、父类中存在同名，子类不存在该名，那么想从子类访问到爷类中的成员，就只能通过爷类中的公开方法来到访问调用。



---

## 方法重写/覆盖Override

### 使用

1. 父子类的方法名、参数列表一致
2. 对于方法类型：
   1. 子类方法的方法类型和父类的方法类型一致，
   2. 或者子类方法的类型属于父类方法类型的子类，例如子类方法类型是String，父类方法类型是Object，那么这两种方法类型就形成了父子关系，那么就可以重载。
3. 方法重载时，子类方法的访问权限不可以低于父类方法的访问权限。

### 用途

在父类中同样存在一样的方法，但因为子类需要特有化，因此需要重写。这样保证了，行为的操作都是一样的，只不过内容发生了变化（即方法名、参数列表不变，代码块里的东西改变）。



----

## 多态Polymorphic

### 用处

可以更加通用普遍的调用对象的成员。我们可以通过父类类型引用来接收其本身类型和子类类型的对象，但同时可以通过该引用去访问对象。

### 体现

1. 方法的多态：重写和重载

2. 对象的多态：

   1. 一个对象的编译类型和运行类型可以不一样。如Object obj = new String();，其中Object就称为编译类型，String称为运行类型。
   2. 编译类型在对象定义的时候及已经确定了，不可再改变（因为不可重复定义）。
   3. 运行类型可以改变（因为可以重新给对象进行赋值）。
   4. 编译类型和运行类型的规则：父类的引用可以指向子类的对象，即**<u>编译类型是运行类型的父类</u>**。

   由于需要进行编译，因此，在父类中也需要有和子类一样的成员才可以在运行时调用子类的成员，否则编译不通过，何谈运行。

### 多态的向上转型

#### 本质

父类的引用指向了子类对象

语法

父类类型 引用名 = new 子类类型(参数)；

父类类型 引用名= 引用名；//右式引用名的类型是一个对应子类类型

#### 特点

1. 可以调用父类所有可访问的成员。
2. 不能调用子类的特有成员。因为在编译阶段，能调用哪些成员,是由编译类型来决定的。
3. 编译类型与运行类型不一致

### 多态的向下转型

#### 本质

用于指向子类对象的父类引用赋值给了对应的子类引用

#### 语法

子类类型 引用名 = （子类类型）父类引用名

#### 特点

1. 父类引用指向的对象必须是对应的子类
2. 向下转型后，通过新的引用可以调用子类中所有可访问的成员。
3. 编译类型和运行类型一致



### 抽象理解

向上转型可以看作：就是我声明了一个父类，然后这个父类中仅有new出来的部分被赋值了。因此可以通过新父类引用访问自己本类中的所有可访问的成员。

向下转型可以看作，就是我声明了一个子类，将另一个地方的子类赋值给这个新声明的子类。然后可以通过新子类引用访问本类中所有可访问的成员。

总结就是：表达式右边都是只为了给左式赋值，<u>**实际上左边的引用名可以调用什么成员，还是得看这个引用名的类型，而无关乎右式的类型。**</u>

### 本质理解

#### 编译与运行

实际上，表达式两侧都需要编译成计算器看得懂得文件，但是不做运行计算的操作，也就是说，只是把表达式两侧的语句以及包含的运算符编译（翻译）了一下，实际上进行运算还是等待下一步进行。

那么就可以知道向上转型，最终就是把右式的结果赋值给了左式，那么就相当于右式的类型才是 实际运行后 左式中引用的类型

所有的操作都是先进行编译后运算的。

#### 内存布局

内存大小：实际上，子类所占用的内存大小一般是比父类要大的。因为子类一般会增加很多的特有的成员。

包含关系：当我们新建一个子类对象时，父类的一些成员已经被包含在里面了，因此我们可以用一个父类的引用去指向那些父类成员，进而通过地址访问父类成员。

构造与地址：因为构造都是从Object的构造器开始构造的，因此不管什么类型，地址的空间地址都是没有差别的：引用所指向的都是Object最先占开辟用的地方。

对于方法：由于堆区存放的是成员属性，方法区存放类的信息加载（方法都存放于此），而继承之间的关系都是从子类不断向上查找父类的，故方法的查找一定是从下往上匹配的。（故会出现方法覆盖/重写）

而对于属性：则由对应对象所决定，即子类可以访问堆中对应子类的属性，父类可以访问对应父类中的属性。（没有属性覆盖的说法）



### 多态参数

#### 定义

方法定义的形参类型为父类类型，实参类型可为子类类型

### 关于多态记住一句话

在写代码的时候，为了编译通过，引用能够访问到一定是引用类型下的成员，而不能够是对象（可能是引用类型本身，也有可能是引用类型的子类）。

但是实际上运行的时候，在底层，我们实际上是能够通过引用名访问到对象的成员（不管是引用类型本身还是子类）。而为了达到这种效果，那么可以这么做：

1. 访问成员：当类型一致时，直接访问；当类型不一致时，强制转换类型。
2. 访问方法：当类型一致时，直接加载对应类的方法，可直接访问；当类型不一致时，若两类之间具有方法重写/覆盖，那么直接调用即可（因为加载时子类的方法也加载进去了，因此会从子类的方法开始向上查找）；若两类之间没有重写，那么就需要强转类型。

重点！！！就是！！！内存中究竟加载了什么信息！！！创建了一个子类对象，那么内存中就一定加载了子类的信息，就一定有办法可以访问得到。



----

## 动态绑定机制

调用对象的方法时，会有动态绑定机制。即该方法会和对象的地址产生绑定。

具体表现就是：无论方法中再调用了多少次其他方法，每调用其他方法一次，就**<u>必须回到对象的地址才能开始查找对应的其他方法</u>**。

对于属性来说，没有动态绑定机制。只看当前作用域。

---



## instanof关键字

**`instanceof` 是 Java 的保留关键字，它的作用是测试它左边的对象是否是它右边的类或者子类的实例，返回 `boolean` 的数据类型**

### 用途

1. 使用子类的成员：
   当把子类对象赋给父类引用变量时，这个父类引用变量只能调用父类拥有的方法，不能调用子类特有的方法，即使它实际引用的是子类对象。
   如果需要让这个父类引用变量调用它子类的特有的方法，就必须把它强制转换成子类类型。

2. 筛选可强转时机（例如多态数组遍历）：
   当数组中的元素是符合子类类型时，那么就进入if代码块进行向下转型。

   使得在此代码块中，可以通过引用名调用子类成员。

3. 判断是否可以正确强转（健壮性）：

   把父类实例转换成子类类型，则这个对象必须实际上是子类实例才行，否则将在运行时引发ClassCastException。在强制转换前使用instanceof运算符判断是否可以成功转换。
   

### 注意

- **基本类型完全不能用于 `instanceof `判断**
- null只能放在 `instanceof` 关键字的左边,且无论右边为什么类型，都返回`false`

---

## 断点调试

可以在调式过程中动态的下断点。

可以在一段复杂的逻辑代码中下多个断点，从而可以判断代码是否是进入该代码块还是跳过该代码块去执行其他代码块

----

## 编程思想

### 代码风格

- **<u>写代码块时，逻辑应该越小越好，保证了低耦合</u>**，使得将来可以扩展到其他代码中，或者进行修改功能。
- 在验证数据时，即判断代码执行条件时，**<u>先判断不正确的数据，即先写错误提示的代码块</u>**。

### 对OOP的思考

多态是在继承和封装的基础上拓展出来的。多态就是方法和对象可以具有多种形态的意思。

于继承：

具体来说，对于方法：Override；对于对象：可用父类类型引用接收子类类型对象。

而这些操作都是基于继承的，没有继承那么就不存在Override，以及父子类关系。

于封装：

又因为对象可以由父类类型接收，因此实际上该引用名可以访问到其类型之下的所有子类。具体操作便基于强转。

紧接着就可以通过各对象中封装后给定的方法来访问到内部信息。所以，可以看作多态就是封装的一种出口。



---

## 程序设计

管理模式：分层模式、mvc

### 分层模式

界面层（view）、业务层（service）、工具层（utils）、实体类（domain）。

#### 业务的完成

一个业务的完成至少需要三层：界面层（view）、业务层（service）、实体类（domain）。

#### 分层介绍

- 界面层、业务层中属性一般都是**<u>用于接收实体类中的信息</u>**，或者**<u>辅助功能实现</u>**的一些变量，然后围绕业务信息，辅以辅助变量来实现当前层的功能。

##### 对于界面层：

界面层用于将业务完成，即将信息，通过功能，来完成具体业务。

1. 需显示所有功能
2. 对于每个功能需有独立界面
3. **<u>界面层作用</u>**：显示提示信息、获取用户输入以及调用业务层的具体实现方法

##### 对于实体类：

实体类用于将业务的信息（属性）抽象化，并成为**<u>一种数据类型</u>**。

1. 创建属性（一般都是私有）
2. 创建所有属性的构造器
3. 提供开放的set()、gert()方法
4. 重写toStrin()方法，用于输出类中的所有属性信息。

##### 对于业务层：

业务层用于将业务的功能（方法）抽象化，并成为一种方法。其中所有功能中的一些公有成员同样可以抽离出来放在本类中，或者异类中。

- 应从用户角度出发。从最先提供给用户的功能开始实现。然后再逐步深入实现其他功能。

#### 业务分包

每层都要分包处理，如com.项目名.模块名.view、com.项目名.模块名.service、com.项目名.模块名.domain



### 实现过程（三部曲，以分层模式为例）

**<u>三部曲：明确功能、分析功能实现思路、实现功能。</u>**

三部曲需按管理模式进行思考，以分层模式为例

#### 明确功能

1. 根据甲方要求，提取业务需要，即功能，并命名为一个或多个方法（方法对应分层）。

#### 分析实现逻辑

1. 从业务需求细分到业务逻辑：在方法中需要实现怎么样的代码块（在明确功能的步骤中，再次对功能进行细化，即将功能划分为一个个代码块）
2. 逻辑分类：（主要按分层来进行思考）
   1. 需要涉及到哪些包
   2. 需要涉及到哪些类

#### 实现功能

1. 要求**<u>化繁为简、由浅入深</u>**，即实现功能的过程不是仅通过一次“三部曲”就可以实现的，而是**<u>通过一遍又一遍重复</u>**才实现目标功能。
2. 最开始是实现肤浅、简单的代码逻辑（一个个代码块），而后慢慢地修改/替换为具体、完好的代码，从而实现目标功能。（**<u>小代码块组合成大代码块</u>**）

#### 注意

谨记一个方法实现一种功能，在分层模式中，业务层和界面层是独立的，不要融合起来。



---



## 关于OOP的CRUD

### 实体类

**<u>多运用接口、继承</u>**

- 在**<u>实体类</u>**中重写toString()方法可以通过引用名直接访问属性信息，即业务的基本信息。
- 有访问权限的业务需求时，那么就可以运用封装的思想，**<u>完成实体类的编写</u>**（属性、构造、set、get，具体细节查看**<u>封装的实现步骤</u>**笔记）。
- 当业务的信息多样，但可以抽离出共有属性时，可以运用继承的思想，**<u>完成实体类的编写</u>**（属性、构造、set、get、重写，具体细节查看**<u>继承</u>**笔记）。
- 当业务有继承的需求时，大多数情况下也可以运用上多态的思想，**<u>完成实体类的访问</u>**（向上、向下转型）。

### 其他层级

**<u>多运用多态</u>**

属性一般都是**<u>用于接收实体类中的信息</u>**，或者**<u>辅助功能实现</u>**的一些变量，然后围绕业务信息，辅以辅助变量来实现当前层的功能。

- 对于属性：此处接收实体类型信息，就可以使用多态，通过父类类型的引用来接收。
- 对于方法：形参则可以设置为父类类型，从而可以接收多种类型的实参
- 对于方法中的代码块
  - 可以通过类型判断（instanceof）来获得访问权限（向下转型）；（此处指访问修饰符、类型对应等等java自带的一些访问机制）
  - 同时也可以通过运行类型，设置一些访问权限。（只有指定的类型才可以拥有访问权限，此处指自定义的访问机制）
