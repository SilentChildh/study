# 任务四

## 步骤

1. 编写properties文件

2. 保存连接实例的集合选择LinkedList

    1. 因为这是一个双向链表，删除（即获取连接）的操作比较灵活
    2. 不使用Set、Map是因为存储进去的是无序的，遍历浪费时间，且键值对也不是必须的，多一个value还浪费空间
    3. 不使用TreeXxx是因为不需要排序

3. 设置成员变量记录活跃数量，该变量满足配置文件中maxActive属性

4. 设置空闲池，即LinkedList集合

    1. 空闲池满足minIdle属性
    2. 最开始时，空闲池默认初始化initialSize个连接实例

5. 设置线程来监保证空闲池中满足minIdle属性（守护线程）

    1. 实践发现，获取资源的速度太快，无法单纯的只用线程补充连接资源。还是得配合getConnection()中的条件语句来阻止外界大量获取资源的行为。
    2. 再额外写一个方法，来符合单一职责原则

    - 但似乎也可以不另写一个方法，而是让该线程sleep一会，给监听线程一点而缓冲的机会就可以了...

6. 核心方法getConnection()

    1. 以空闲池集合实例为锁，进行资源控制
    2. 设置线程来监控getConnection方法中是否满足maxWait属性
    3. 获取资源前判断目前连接活跃数量，满足maxActive属性则可以获取资源（该处另写一个boolean方法，实现单一职责原则）
    4. 获取连接资源用removeFirst方法，这样子可以避免遍历
    5. 每获取一个资源，令连接活跃数量自增

7. 重要方法reclaim()

    1. 利用add()将连接资源回收，该方法与removeFirst方法正好对应。（头删尾增）
    2. 每回收一个资源，令连接活跃数量自减

8. 添加一个全局的日志（在另一个类中），用于打印。

    1. 个人认为异常遍布的位置更特殊，是为了交互而用，更偏向于给用户看（controller处理异常后用其他页面代替异常展示给用户看）。（以下自定义的异常并未向上传递，而是直接打印异常，简单一点...）
    2. 日志是一个打印日常工作报告的东西，应用性较异常少，更偏向于给程序员看
    3. 日志打印的东西包括异常

9. 最终还是把异常提取出来，写成一个异常类。因为认为以后线程池的相关数据也可以用到这些异常类

10. 一些辅助void方法统一换为引用类型Void，使其适用于泛型、反射。



## properties

~~~properties
driverClassName=com.mysql.cj.jdbc.Driver
#URL连接数据库的URL，
url=jdbc:mysql://localhost:3306/db_01?rewriteBatchStatement=true

characterEncoding=utf-8

#安装mysql时候设置的用户与密码
username=root
password=root

#初始化物理连接的个数
initialSize=10

#空闲池小连接数
minIdle=5

#活跃时最大连接池数量
maxActive=20

#获取连接时最大等待时间
maxWait=5000

~~~



## 升级

利用动态代理，强行让jvm调用自定义的reclaim，而不是java.sql.Connection的close方法

1. 匿名内部类来创建InvocationHandler的实现类（底层帮我们创建了）
2. 内部类成员为Connection
3. 重写invoke方法

~~~java
private static Connection getProxyConnection() {
        return (Connection) Proxy.newProxyInstance(Connection.class.getClassLoader(), new Class[] {Connection.class},
                new InvocationHandler() {
                    private Connection connection;
                    {
                        try {
                            connection = DriverManager.getConnection(url, user, pwd);
                        } catch (SQLException e) {
                            throw new RuntimeException("连接资源入池失败");
                        }
                    }

                    @Override
                    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                        // 如果调用的是close方法，则调用自定义数据库连接池的reclaim方法
                        if ("close".equals(method.getName())) {
                            return reclaim(connection);
                        }
                        // 如果是其他方法则无所谓了
                        return method.invoke(connection, args);
                    }
                });

    }
~~~

出现的问题：

1. 第二个参数需要的是一个接口的Class数组，但由于Connection接口没有父接口，故必须得new一个数组，以免为空。且Connection作为一个接口，就是需要交给底层$proxy0实现的。